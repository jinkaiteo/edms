============================= test session starts ==============================
platform linux -- Python 3.11.14, pytest-7.4.3, pluggy-1.6.0 -- /usr/local/bin/python
cachedir: .pytest_cache
django: version: 4.2.16, settings: edms.settings.production (from env)
rootdir: /app
configfile: pytest.ini
plugins: cov-4.1.0, Faker-20.1.0, django-4.7.0
collecting ... collected 88 items

apps/documents/tests/test_document_dependencies.py::TestDocumentDependencies::test_add_dependency_to_document PASSED [  1%]
apps/documents/tests/test_document_dependencies.py::TestDocumentDependencies::test_circular_dependency_prevented PASSED [  2%]
apps/documents/tests/test_document_dependencies.py::TestDocumentDependencies::test_indirect_circular_dependency_prevented PASSED [  3%]
apps/documents/tests/test_document_dependencies.py::TestDocumentDependencies::test_self_dependency_prevented PASSED [  4%]
apps/documents/tests/test_document_dependencies.py::TestDocumentDependencies::test_multiple_dependencies_allowed PASSED [  5%]
apps/documents/tests/test_document_dependencies.py::TestDocumentDependencies::test_critical_dependency_flag PASSED [  6%]
apps/documents/tests/test_document_dependencies.py::TestDocumentDependencies::test_dependency_types PASSED [  7%]
apps/documents/tests/test_document_dependencies.py::TestDocumentDependencies::test_dependency_on_draft_document PASSED [  9%]
apps/documents/tests/test_document_dependencies.py::TestDocumentDependencies::test_version_aware_circular_dependency_detection PASSED [ 10%]
apps/documents/tests/test_document_dependencies.py::TestDocumentDependencies::test_get_dependency_chain PASSED [ 11%]
apps/documents/tests/test_document_dependencies.py::TestDocumentDependencies::test_remove_dependency PASSED [ 12%]
apps/documents/tests/test_document_dependencies.py::TestDocumentDependencies::test_detect_circular_dependencies_system_wide PASSED [ 13%]
apps/workflows/tests/test_approval_workflow.py::TestSubmitForApproval::test_can_submit_reviewed_document_for_approval ERROR [ 14%]
apps/workflows/tests/test_approval_workflow.py::TestSubmitForApproval::test_cannot_submit_draft_for_approval ERROR [ 15%]
apps/workflows/tests/test_approval_workflow.py::TestApproverActions::test_approver_can_approve_document_with_effective_date ERROR [ 17%]
apps/workflows/tests/test_approval_workflow.py::TestApproverActions::test_approver_can_approve_with_immediate_effective_date ERROR [ 18%]
apps/workflows/tests/test_approval_workflow.py::TestApproverActions::test_approver_can_reject_document ERROR [ 19%]
apps/workflows/tests/test_approval_workflow.py::TestApproverActions::test_non_approver_cannot_approve_document ERROR [ 20%]
apps/workflows/tests/test_approval_workflow.py::TestApproverActions::test_approval_requires_effective_date ERROR [ 21%]
apps/workflows/tests/test_approval_workflow.py::TestApproverActions::test_cannot_approve_draft_document ERROR [ 22%]
apps/workflows/tests/test_approval_workflow.py::TestApproverActions::test_effective_date_cannot_be_in_past ERROR [ 23%]
apps/workflows/tests/test_approval_workflow.py::TestAutomaticEffectiveActivation::test_document_becomes_effective_on_scheduled_date ERROR [ 25%]
apps/workflows/tests/test_approval_workflow.py::TestAutomaticEffectiveActivation::test_future_dated_documents_remain_pending ERROR [ 26%]
apps/workflows/tests/test_obsolescence_workflow.py::TestDocumentObsolescence::test_approver_can_mark_document_obsolete ERROR [ 27%]
apps/workflows/tests/test_obsolescence_workflow.py::TestDocumentObsolescence::test_obsolescence_requires_reason ERROR [ 28%]
apps/workflows/tests/test_obsolescence_workflow.py::TestDocumentObsolescence::test_scheduled_obsolescence_date ERROR [ 29%]
apps/workflows/tests/test_obsolescence_workflow.py::TestDocumentObsolescence::test_immediate_obsolescence ERROR [ 30%]
apps/workflows/tests/test_obsolescence_workflow.py::TestDocumentObsolescence::test_cannot_obsolete_non_effective_document ERROR [ 31%]
apps/workflows/tests/test_obsolescence_workflow.py::TestDocumentObsolescence::test_author_cannot_mark_obsolete ERROR [ 32%]
apps/workflows/tests/test_obsolescence_workflow.py::TestDocumentObsolescence::test_obsolete_documents_are_read_only ERROR [ 34%]
apps/workflows/tests/test_review_workflow.py::TestSubmitForReview::test_author_can_submit_document_for_review ERROR [ 35%]
apps/workflows/tests/test_review_workflow.py::TestSubmitForReview::test_non_author_cannot_submit_for_review ERROR [ 36%]
apps/workflows/tests/test_review_workflow.py::TestSubmitForReview::test_cannot_submit_already_reviewed_document ERROR [ 37%]
apps/workflows/tests/test_review_workflow.py::TestReviewerActions::test_reviewer_can_approve_document ERROR [ 38%]
apps/workflows/tests/test_review_workflow.py::TestReviewerActions::test_reviewer_can_reject_document ERROR [ 39%]
apps/workflows/tests/test_review_workflow.py::TestReviewerActions::test_non_reviewer_cannot_approve_document ERROR [ 40%]
apps/workflows/tests/test_review_workflow.py::TestReviewerActions::test_author_cannot_review_own_document ERROR [ 42%]
apps/workflows/tests/test_review_workflow.py::TestReviewerActions::test_review_requires_comment ERROR [ 43%]
apps/workflows/tests/test_review_workflow.py::TestReviewerActions::test_cannot_review_draft_document ERROR [ 44%]
apps/workflows/tests/test_termination_workflow.py::TestDocumentTermination::test_author_can_terminate_draft_document ERROR [ 45%]
apps/workflows/tests/test_termination_workflow.py::TestDocumentTermination::test_author_can_terminate_under_review_document ERROR [ 46%]
apps/workflows/tests/test_termination_workflow.py::TestDocumentTermination::test_author_can_terminate_pending_approval_document ERROR [ 47%]
apps/workflows/tests/test_termination_workflow.py::TestDocumentTermination::test_termination_requires_reason ERROR [ 48%]
apps/workflows/tests/test_termination_workflow.py::TestDocumentTermination::test_cannot_terminate_effective_document ERROR [ 50%]
apps/workflows/tests/test_termination_workflow.py::TestDocumentTermination::test_non_author_cannot_terminate ERROR [ 51%]
apps/workflows/tests/test_termination_workflow.py::TestDocumentTermination::test_terminated_documents_are_read_only ERROR [ 52%]
apps/workflows/tests/test_versioning_workflow.py::TestDocumentVersioning::test_create_major_version_from_effective_document FAILED [ 53%]
apps/workflows/tests/test_versioning_workflow.py::TestDocumentVersioning::test_create_minor_version_from_effective_document FAILED [ 54%]
apps/workflows/tests/test_versioning_workflow.py::TestDocumentVersioning::test_cannot_version_non_effective_document FAILED [ 55%]
apps/workflows/tests/test_versioning_workflow.py::TestDocumentVersioning::test_versioned_document_follows_full_workflow FAILED [ 56%]
apps/workflows/tests/test_versioning_workflow.py::TestDocumentVersioning::test_old_version_superseded_when_new_version_effective PASSED [ 57%]
apps/workflows/tests/test_versioning_workflow.py::TestDocumentVersioning::test_version_numbering_format FAILED [ 59%]
apps/workflows/tests/test_versioning_workflow.py::TestDocumentVersioning::test_version_inherits_document_type_and_source PASSED [ 60%]
apps/workflows/tests/test_versioning_workflow.py::TestDocumentVersioning::test_multiple_versions_chain FAILED [ 61%]
apps/workflows/tests/test_versioning_workflow.py::TestDocumentVersioning::test_versioning_preserves_dependencies PASSED [ 62%]
apps/workflows/tests/test_versioning_workflow.py::TestDocumentVersioning::test_cannot_create_version_without_reason FAILED [ 63%]
apps/workflows/tests/test_versioning_workflow.py::TestDocumentVersioning::test_superseded_documents_are_read_only PASSED [ 64%]
apps/workflows/tests/test_workflow_notifications.py::TestWorkflowNotifications::test_notification_created_on_submit_for_review FAILED [ 65%]
apps/workflows/tests/test_workflow_notifications.py::TestWorkflowNotifications::test_notification_created_on_submit_for_review ERROR [ 65%]
apps/workflows/tests/test_workflow_notifications.py::TestWorkflowNotifications::test_notification_created_on_rejection FAILED [ 67%]
apps/workflows/tests/test_workflow_notifications.py::TestWorkflowNotifications::test_notification_created_on_approval FAILED [ 68%]
apps/workflows/tests/test_workflow_notifications.py::TestWorkflowNotifications::test_notification_read_status PASSED [ 69%]
apps/workflows/tests/test_workflow_notifications.py::TestWorkflowNotifications::test_multiple_recipients_receive_notifications PASSED [ 70%]
apps/workflows/tests/test_workflow_rejections.py::TestReviewRejections::test_reject_with_detailed_comment ERROR [ 71%]
apps/workflows/tests/test_workflow_rejections.py::TestReviewRejections::test_reject_without_comment_should_fail ERROR [ 72%]
apps/workflows/tests/test_workflow_rejections.py::TestReviewRejections::test_rejection_creates_audit_trail ERROR [ 73%]
apps/workflows/tests/test_workflow_rejections.py::TestReviewRejections::test_author_notified_of_rejection ERROR [ 75%]
apps/workflows/tests/test_workflow_rejections.py::TestApprovalRejections::test_approver_reject_with_reason ERROR [ 76%]
apps/workflows/tests/test_workflow_rejections.py::TestApprovalRejections::test_approval_rejection_bypasses_review ERROR [ 77%]
apps/workflows/tests/test_workflow_rejections.py::TestRejectionWorkflowBehavior::test_document_can_be_resubmitted_after_rejection ERROR [ 78%]
apps/workflows/tests/test_workflow_rejections.py::TestRejectionWorkflowBehavior::test_rejection_count_tracking ERROR [ 79%]
apps/workflows/tests/test_workflow_rejections.py::TestRejectionWorkflowBehavior::test_multiple_rejection_cycles ERROR [ 80%]
apps/scheduler/tests/test_document_activation.py::TestSchedulerDocumentActivation::test_document_becomes_effective_on_scheduled_date PASSED [ 81%]
apps/scheduler/tests/test_document_activation.py::TestSchedulerDocumentActivation::test_future_dated_documents_remain_pending PASSED [ 82%]
apps/scheduler/tests/test_document_activation.py::TestSchedulerDocumentActivation::test_scheduler_activates_multiple_documents PASSED [ 84%]
apps/scheduler/tests/test_document_activation.py::TestSchedulerDocumentActivation::test_past_dated_documents_activated_immediately PASSED [ 85%]
apps/scheduler/tests/test_document_activation.py::TestSchedulerDocumentActivation::test_scheduler_skips_non_pending_documents PASSED [ 86%]
apps/scheduler/tests/test_document_activation.py::TestSchedulerDocumentActivation::test_scheduler_timezone_handling PASSED [ 87%]
apps/scheduler/tests/test_obsolescence_automation.py::TestSchedulerObsolescence::test_scheduler_marks_documents_obsolete_on_date PASSED [ 88%]
apps/scheduler/tests/test_obsolescence_automation.py::TestSchedulerObsolescence::test_future_obsolescence_remains_scheduled PASSED [ 89%]
apps/scheduler/tests/test_obsolescence_automation.py::TestSchedulerObsolescence::test_past_obsolescence_processed_immediately PASSED [ 90%]
apps/audit/tests/test_workflow_audit_trail.py::TestWorkflowAuditTrail::test_audit_trail_created_on_status_change ERROR [ 92%]
apps/audit/tests/test_workflow_audit_trail.py::TestWorkflowAuditTrail::test_audit_trail_captures_user_info ERROR [ 93%]
apps/audit/tests/test_workflow_audit_trail.py::TestWorkflowAuditTrail::test_audit_trail_captures_timestamp ERROR [ 94%]
apps/audit/tests/test_workflow_audit_trail.py::TestWorkflowAuditTrail::test_audit_trail_captures_status_change ERROR [ 95%]
apps/audit/tests/test_workflow_audit_trail.py::TestWorkflowAuditTrail::test_audit_trail_captures_comment ERROR [ 96%]
apps/audit/tests/test_workflow_audit_trail.py::TestWorkflowAuditTrail::test_audit_trail_is_immutable ERROR [ 97%]
apps/audit/tests/test_workflow_audit_trail.py::TestWorkflowAuditTrail::test_audit_trail_filtering_by_user ERROR [ 98%]
apps/audit/tests/test_workflow_audit_trail.py::TestWorkflowAuditTrail::test_complete_workflow_audit_trail ERROR [100%]

==================================== ERRORS ====================================
_ ERROR at setup of TestSubmitForApproval.test_can_submit_reviewed_document_for_approval _

self = <apps.workflows.tests.test_approval_workflow.TestSubmitForApproval object at 0x7e0a00760090>

    def setup_method(self):
        """Setup test data"""
        self.client = APIClient()
    
        # Create users
        self.author = User.objects.create_user(
            username='test_author',
            password='test123'
        )
    
        self.reviewer = User.objects.create_user(
            username='test_reviewer',
            password='test123'
        )
    
        self.approver = User.objects.create_user(
            username='test_approver',
            password='test123'
        )
    
        # Assign approver role
        approver_role, _ = Role.objects.get_or_create(
            name='Document Approver',
            defaults={
                'module': 'S2',
                'permission_level': 'approver'
            }
        )
        UserRole.objects.create(
            user=self.approver,
            role=approver_role,
            is_active=True
        )
    
        # Create document type
>       self.doc_type = DocumentType.objects.create(
            code='TST',
            name='Test Document',
            prefix='TST'
        )

apps/workflows/tests/test_approval_workflow.py:64: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.11/site-packages/django/db/models/manager.py:87: in manager_method
    return getattr(self.get_queryset(), name)(*args, **kwargs)
/usr/local/lib/python3.11/site-packages/django/db/models/query.py:656: in create
    obj = self.model(**kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <DocumentType: Test Document (TST)>, args = ()
kwargs = {'prefix': 'TST'}, cls = <class 'apps.documents.models.DocumentType'>
opts = <Options for DocumentType>, _setattr = <built-in function setattr>
_DEFERRED = <Deferred field>
fields_iter = <tuple_iterator object at 0x7e09ffd8c940>, val = {}
field = <django.db.models.fields.json.JSONField: metadata>
is_related_object = False, property_names = frozenset({'pk'})

    def __init__(self, *args, **kwargs):
        # Alias some things as locals to avoid repeat global lookups
        cls = self.__class__
        opts = self._meta
        _setattr = setattr
        _DEFERRED = DEFERRED
        if opts.abstract:
            raise TypeError("Abstract models cannot be instantiated.")
    
        pre_init.send(sender=cls, args=args, kwargs=kwargs)
    
        # Set up the storage for instance state
        self._state = ModelState()
    
        # There is a rather weird disparity here; if kwargs, it's set, then args
        # overrides it. It should be one or the other; don't duplicate the work
        # The reason for the kwargs check is that standard iterator passes in by
        # args, and instantiation for iteration is 33% faster.
        if len(args) > len(opts.concrete_fields):
            # Daft, but matches old exception sans the err msg.
            raise IndexError("Number of args exceeds number of fields")
    
        if not kwargs:
            fields_iter = iter(opts.concrete_fields)
            # The ordering of the zip calls matter - zip throws StopIteration
            # when an iter throws it. So if the first iter throws it, the second
            # is *not* consumed. We rely on this, so don't change the order
            # without changing the logic.
            for val, field in zip(args, fields_iter):
                if val is _DEFERRED:
                    continue
                _setattr(self, field.attname, val)
        else:
            # Slower, kwargs-ready version.
            fields_iter = iter(opts.fields)
            for val, field in zip(args, fields_iter):
                if val is _DEFERRED:
                    continue
                _setattr(self, field.attname, val)
                if kwargs.pop(field.name, NOT_PROVIDED) is not NOT_PROVIDED:
                    raise TypeError(
                        f"{cls.__qualname__}() got both positional and "
                        f"keyword arguments for field '{field.name}'."
                    )
    
        # Now we're left with the unprocessed fields that *must* come from
        # keywords, or default.
    
        for field in fields_iter:
            is_related_object = False
            # Virtual field
            if field.attname not in kwargs and field.column is None:
                continue
            if kwargs:
                if isinstance(field.remote_field, ForeignObjectRel):
                    try:
                        # Assume object instance was passed in.
                        rel_obj = kwargs.pop(field.name)
                        is_related_object = True
                    except KeyError:
                        try:
                            # Object instance wasn't passed in -- must be an ID.
                            val = kwargs.pop(field.attname)
                        except KeyError:
                            val = field.get_default()
                else:
                    try:
                        val = kwargs.pop(field.attname)
                    except KeyError:
                        # This is done with an exception rather than the
                        # default argument on pop because we don't want
                        # get_default() to be evaluated, and then not used.
                        # Refs #12057.
                        val = field.get_default()
            else:
                val = field.get_default()
    
            if is_related_object:
                # If we are passed a related instance, set it using the
                # field.name instead of field.attname (e.g. "user" instead of
                # "user_id") so that the object gets properly cached (and type
                # checked) by the RelatedObjectDescriptor.
                if rel_obj is not _DEFERRED:
                    _setattr(self, field.name, rel_obj)
            else:
                if val is not _DEFERRED:
                    _setattr(self, field.attname, val)
    
        if kwargs:
            property_names = opts._property_names
            unexpected = ()
            for prop, value in kwargs.items():
                # Any remaining kwargs must correspond to properties or virtual
                # fields.
                if prop in property_names:
                    if value is not _DEFERRED:
                        _setattr(self, prop, value)
                else:
                    try:
                        opts.get_field(prop)
                    except FieldDoesNotExist:
                        unexpected += (prop,)
                    else:
                        if value is not _DEFERRED:
                            _setattr(self, prop, value)
            if unexpected:
                unexpected_names = ", ".join(repr(n) for n in unexpected)
>               raise TypeError(
                    f"{cls.__name__}() got unexpected keyword arguments: "
                    f"{unexpected_names}"
                )
E               TypeError: DocumentType() got unexpected keyword arguments: 'prefix'

/usr/local/lib/python3.11/site-packages/django/db/models/base.py:567: TypeError
_ ERROR at setup of TestSubmitForApproval.test_cannot_submit_draft_for_approval _

self = <apps.workflows.tests.test_approval_workflow.TestSubmitForApproval object at 0x7e0a005f8c10>

    def setup_method(self):
        """Setup test data"""
        self.client = APIClient()
    
        # Create users
        self.author = User.objects.create_user(
            username='test_author',
            password='test123'
        )
    
        self.reviewer = User.objects.create_user(
            username='test_reviewer',
            password='test123'
        )
    
        self.approver = User.objects.create_user(
            username='test_approver',
            password='test123'
        )
    
        # Assign approver role
        approver_role, _ = Role.objects.get_or_create(
            name='Document Approver',
            defaults={
                'module': 'S2',
                'permission_level': 'approver'
            }
        )
        UserRole.objects.create(
            user=self.approver,
            role=approver_role,
            is_active=True
        )
    
        # Create document type
>       self.doc_type = DocumentType.objects.create(
            code='TST',
            name='Test Document',
            prefix='TST'
        )

apps/workflows/tests/test_approval_workflow.py:64: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.11/site-packages/django/db/models/manager.py:87: in manager_method
    return getattr(self.get_queryset(), name)(*args, **kwargs)
/usr/local/lib/python3.11/site-packages/django/db/models/query.py:656: in create
    obj = self.model(**kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <DocumentType: Test Document (TST)>, args = ()
kwargs = {'prefix': 'TST'}, cls = <class 'apps.documents.models.DocumentType'>
opts = <Options for DocumentType>, _setattr = <built-in function setattr>
_DEFERRED = <Deferred field>
fields_iter = <tuple_iterator object at 0x7e0a00413af0>, val = {}
field = <django.db.models.fields.json.JSONField: metadata>
is_related_object = False, property_names = frozenset({'pk'})

    def __init__(self, *args, **kwargs):
        # Alias some things as locals to avoid repeat global lookups
        cls = self.__class__
        opts = self._meta
        _setattr = setattr
        _DEFERRED = DEFERRED
        if opts.abstract:
            raise TypeError("Abstract models cannot be instantiated.")
    
        pre_init.send(sender=cls, args=args, kwargs=kwargs)
    
        # Set up the storage for instance state
        self._state = ModelState()
    
        # There is a rather weird disparity here; if kwargs, it's set, then args
        # overrides it. It should be one or the other; don't duplicate the work
        # The reason for the kwargs check is that standard iterator passes in by
        # args, and instantiation for iteration is 33% faster.
        if len(args) > len(opts.concrete_fields):
            # Daft, but matches old exception sans the err msg.
            raise IndexError("Number of args exceeds number of fields")
    
        if not kwargs:
            fields_iter = iter(opts.concrete_fields)
            # The ordering of the zip calls matter - zip throws StopIteration
            # when an iter throws it. So if the first iter throws it, the second
            # is *not* consumed. We rely on this, so don't change the order
            # without changing the logic.
            for val, field in zip(args, fields_iter):
                if val is _DEFERRED:
                    continue
                _setattr(self, field.attname, val)
        else:
            # Slower, kwargs-ready version.
            fields_iter = iter(opts.fields)
            for val, field in zip(args, fields_iter):
                if val is _DEFERRED:
                    continue
                _setattr(self, field.attname, val)
                if kwargs.pop(field.name, NOT_PROVIDED) is not NOT_PROVIDED:
                    raise TypeError(
                        f"{cls.__qualname__}() got both positional and "
                        f"keyword arguments for field '{field.name}'."
                    )
    
        # Now we're left with the unprocessed fields that *must* come from
        # keywords, or default.
    
        for field in fields_iter:
            is_related_object = False
            # Virtual field
            if field.attname not in kwargs and field.column is None:
                continue
            if kwargs:
                if isinstance(field.remote_field, ForeignObjectRel):
                    try:
                        # Assume object instance was passed in.
                        rel_obj = kwargs.pop(field.name)
                        is_related_object = True
                    except KeyError:
                        try:
                            # Object instance wasn't passed in -- must be an ID.
                            val = kwargs.pop(field.attname)
                        except KeyError:
                            val = field.get_default()
                else:
                    try:
                        val = kwargs.pop(field.attname)
                    except KeyError:
                        # This is done with an exception rather than the
                        # default argument on pop because we don't want
                        # get_default() to be evaluated, and then not used.
                        # Refs #12057.
                        val = field.get_default()
            else:
                val = field.get_default()
    
            if is_related_object:
                # If we are passed a related instance, set it using the
                # field.name instead of field.attname (e.g. "user" instead of
                # "user_id") so that the object gets properly cached (and type
                # checked) by the RelatedObjectDescriptor.
                if rel_obj is not _DEFERRED:
                    _setattr(self, field.name, rel_obj)
            else:
                if val is not _DEFERRED:
                    _setattr(self, field.attname, val)
    
        if kwargs:
            property_names = opts._property_names
            unexpected = ()
            for prop, value in kwargs.items():
                # Any remaining kwargs must correspond to properties or virtual
                # fields.
                if prop in property_names:
                    if value is not _DEFERRED:
                        _setattr(self, prop, value)
                else:
                    try:
                        opts.get_field(prop)
                    except FieldDoesNotExist:
                        unexpected += (prop,)
                    else:
                        if value is not _DEFERRED:
                            _setattr(self, prop, value)
            if unexpected:
                unexpected_names = ", ".join(repr(n) for n in unexpected)
>               raise TypeError(
                    f"{cls.__name__}() got unexpected keyword arguments: "
                    f"{unexpected_names}"
                )
E               TypeError: DocumentType() got unexpected keyword arguments: 'prefix'

/usr/local/lib/python3.11/site-packages/django/db/models/base.py:567: TypeError
_ ERROR at setup of TestApproverActions.test_approver_can_approve_document_with_effective_date _

self = <apps.workflows.tests.test_approval_workflow.TestApproverActions object at 0x7e0a005f95d0>

    def setup_method(self):
        """Setup test data with document ready for approval"""
        self.client = APIClient()
    
        # Create users
        self.author = User.objects.create_user(
            username='test_author',
            password='test123'
        )
    
        self.approver = User.objects.create_user(
            username='test_approver',
            password='test123'
        )
    
        self.other_user = User.objects.create_user(
            username='other_user',
            password='test123'
        )
    
        # Assign approver role
        approver_role, _ = Role.objects.get_or_create(
            name='Document Approver',
            defaults={
                'module': 'S2',
                'permission_level': 'approver'
            }
        )
        UserRole.objects.create(
            user=self.approver,
            role=approver_role,
            is_active=True
        )
    
        # Create document type
>       self.doc_type = DocumentType.objects.create(
            code='TST',
            name='Test Document',
            prefix='TST'
        )

apps/workflows/tests/test_approval_workflow.py:157: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.11/site-packages/django/db/models/manager.py:87: in manager_method
    return getattr(self.get_queryset(), name)(*args, **kwargs)
/usr/local/lib/python3.11/site-packages/django/db/models/query.py:656: in create
    obj = self.model(**kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <DocumentType: Test Document (TST)>, args = ()
kwargs = {'prefix': 'TST'}, cls = <class 'apps.documents.models.DocumentType'>
opts = <Options for DocumentType>, _setattr = <built-in function setattr>
_DEFERRED = <Deferred field>
fields_iter = <tuple_iterator object at 0x7e09ffd23dc0>, val = {}
field = <django.db.models.fields.json.JSONField: metadata>
is_related_object = False, property_names = frozenset({'pk'})

    def __init__(self, *args, **kwargs):
        # Alias some things as locals to avoid repeat global lookups
        cls = self.__class__
        opts = self._meta
        _setattr = setattr
        _DEFERRED = DEFERRED
        if opts.abstract:
            raise TypeError("Abstract models cannot be instantiated.")
    
        pre_init.send(sender=cls, args=args, kwargs=kwargs)
    
        # Set up the storage for instance state
        self._state = ModelState()
    
        # There is a rather weird disparity here; if kwargs, it's set, then args
        # overrides it. It should be one or the other; don't duplicate the work
        # The reason for the kwargs check is that standard iterator passes in by
        # args, and instantiation for iteration is 33% faster.
        if len(args) > len(opts.concrete_fields):
            # Daft, but matches old exception sans the err msg.
            raise IndexError("Number of args exceeds number of fields")
    
        if not kwargs:
            fields_iter = iter(opts.concrete_fields)
            # The ordering of the zip calls matter - zip throws StopIteration
            # when an iter throws it. So if the first iter throws it, the second
            # is *not* consumed. We rely on this, so don't change the order
            # without changing the logic.
            for val, field in zip(args, fields_iter):
                if val is _DEFERRED:
                    continue
                _setattr(self, field.attname, val)
        else:
            # Slower, kwargs-ready version.
            fields_iter = iter(opts.fields)
            for val, field in zip(args, fields_iter):
                if val is _DEFERRED:
                    continue
                _setattr(self, field.attname, val)
                if kwargs.pop(field.name, NOT_PROVIDED) is not NOT_PROVIDED:
                    raise TypeError(
                        f"{cls.__qualname__}() got both positional and "
                        f"keyword arguments for field '{field.name}'."
                    )
    
        # Now we're left with the unprocessed fields that *must* come from
        # keywords, or default.
    
        for field in fields_iter:
            is_related_object = False
            # Virtual field
            if field.attname not in kwargs and field.column is None:
                continue
            if kwargs:
                if isinstance(field.remote_field, ForeignObjectRel):
                    try:
                        # Assume object instance was passed in.
                        rel_obj = kwargs.pop(field.name)
                        is_related_object = True
                    except KeyError:
                        try:
                            # Object instance wasn't passed in -- must be an ID.
                            val = kwargs.pop(field.attname)
                        except KeyError:
                            val = field.get_default()
                else:
                    try:
                        val = kwargs.pop(field.attname)
                    except KeyError:
                        # This is done with an exception rather than the
                        # default argument on pop because we don't want
                        # get_default() to be evaluated, and then not used.
                        # Refs #12057.
                        val = field.get_default()
            else:
                val = field.get_default()
    
            if is_related_object:
                # If we are passed a related instance, set it using the
                # field.name instead of field.attname (e.g. "user" instead of
                # "user_id") so that the object gets properly cached (and type
                # checked) by the RelatedObjectDescriptor.
                if rel_obj is not _DEFERRED:
                    _setattr(self, field.name, rel_obj)
            else:
                if val is not _DEFERRED:
                    _setattr(self, field.attname, val)
    
        if kwargs:
            property_names = opts._property_names
            unexpected = ()
            for prop, value in kwargs.items():
                # Any remaining kwargs must correspond to properties or virtual
                # fields.
                if prop in property_names:
                    if value is not _DEFERRED:
                        _setattr(self, prop, value)
                else:
                    try:
                        opts.get_field(prop)
                    except FieldDoesNotExist:
                        unexpected += (prop,)
                    else:
                        if value is not _DEFERRED:
                            _setattr(self, prop, value)
            if unexpected:
                unexpected_names = ", ".join(repr(n) for n in unexpected)
>               raise TypeError(
                    f"{cls.__name__}() got unexpected keyword arguments: "
                    f"{unexpected_names}"
                )
E               TypeError: DocumentType() got unexpected keyword arguments: 'prefix'

/usr/local/lib/python3.11/site-packages/django/db/models/base.py:567: TypeError
_ ERROR at setup of TestApproverActions.test_approver_can_approve_with_immediate_effective_date _

self = <apps.workflows.tests.test_approval_workflow.TestApproverActions object at 0x7e0a005f9d10>

    def setup_method(self):
        """Setup test data with document ready for approval"""
        self.client = APIClient()
    
        # Create users
        self.author = User.objects.create_user(
            username='test_author',
            password='test123'
        )
    
        self.approver = User.objects.create_user(
            username='test_approver',
            password='test123'
        )
    
        self.other_user = User.objects.create_user(
            username='other_user',
            password='test123'
        )
    
        # Assign approver role
        approver_role, _ = Role.objects.get_or_create(
            name='Document Approver',
            defaults={
                'module': 'S2',
                'permission_level': 'approver'
            }
        )
        UserRole.objects.create(
            user=self.approver,
            role=approver_role,
            is_active=True
        )
    
        # Create document type
>       self.doc_type = DocumentType.objects.create(
            code='TST',
            name='Test Document',
            prefix='TST'
        )

apps/workflows/tests/test_approval_workflow.py:157: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.11/site-packages/django/db/models/manager.py:87: in manager_method
    return getattr(self.get_queryset(), name)(*args, **kwargs)
/usr/local/lib/python3.11/site-packages/django/db/models/query.py:656: in create
    obj = self.model(**kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <DocumentType: Test Document (TST)>, args = ()
kwargs = {'prefix': 'TST'}, cls = <class 'apps.documents.models.DocumentType'>
opts = <Options for DocumentType>, _setattr = <built-in function setattr>
_DEFERRED = <Deferred field>
fields_iter = <tuple_iterator object at 0x7e0a00090820>, val = {}
field = <django.db.models.fields.json.JSONField: metadata>
is_related_object = False, property_names = frozenset({'pk'})

    def __init__(self, *args, **kwargs):
        # Alias some things as locals to avoid repeat global lookups
        cls = self.__class__
        opts = self._meta
        _setattr = setattr
        _DEFERRED = DEFERRED
        if opts.abstract:
            raise TypeError("Abstract models cannot be instantiated.")
    
        pre_init.send(sender=cls, args=args, kwargs=kwargs)
    
        # Set up the storage for instance state
        self._state = ModelState()
    
        # There is a rather weird disparity here; if kwargs, it's set, then args
        # overrides it. It should be one or the other; don't duplicate the work
        # The reason for the kwargs check is that standard iterator passes in by
        # args, and instantiation for iteration is 33% faster.
        if len(args) > len(opts.concrete_fields):
            # Daft, but matches old exception sans the err msg.
            raise IndexError("Number of args exceeds number of fields")
    
        if not kwargs:
            fields_iter = iter(opts.concrete_fields)
            # The ordering of the zip calls matter - zip throws StopIteration
            # when an iter throws it. So if the first iter throws it, the second
            # is *not* consumed. We rely on this, so don't change the order
            # without changing the logic.
            for val, field in zip(args, fields_iter):
                if val is _DEFERRED:
                    continue
                _setattr(self, field.attname, val)
        else:
            # Slower, kwargs-ready version.
            fields_iter = iter(opts.fields)
            for val, field in zip(args, fields_iter):
                if val is _DEFERRED:
                    continue
                _setattr(self, field.attname, val)
                if kwargs.pop(field.name, NOT_PROVIDED) is not NOT_PROVIDED:
                    raise TypeError(
                        f"{cls.__qualname__}() got both positional and "
                        f"keyword arguments for field '{field.name}'."
                    )
    
        # Now we're left with the unprocessed fields that *must* come from
        # keywords, or default.
    
        for field in fields_iter:
            is_related_object = False
            # Virtual field
            if field.attname not in kwargs and field.column is None:
                continue
            if kwargs:
                if isinstance(field.remote_field, ForeignObjectRel):
                    try:
                        # Assume object instance was passed in.
                        rel_obj = kwargs.pop(field.name)
                        is_related_object = True
                    except KeyError:
                        try:
                            # Object instance wasn't passed in -- must be an ID.
                            val = kwargs.pop(field.attname)
                        except KeyError:
                            val = field.get_default()
                else:
                    try:
                        val = kwargs.pop(field.attname)
                    except KeyError:
                        # This is done with an exception rather than the
                        # default argument on pop because we don't want
                        # get_default() to be evaluated, and then not used.
                        # Refs #12057.
                        val = field.get_default()
            else:
                val = field.get_default()
    
            if is_related_object:
                # If we are passed a related instance, set it using the
                # field.name instead of field.attname (e.g. "user" instead of
                # "user_id") so that the object gets properly cached (and type
                # checked) by the RelatedObjectDescriptor.
                if rel_obj is not _DEFERRED:
                    _setattr(self, field.name, rel_obj)
            else:
                if val is not _DEFERRED:
                    _setattr(self, field.attname, val)
    
        if kwargs:
            property_names = opts._property_names
            unexpected = ()
            for prop, value in kwargs.items():
                # Any remaining kwargs must correspond to properties or virtual
                # fields.
                if prop in property_names:
                    if value is not _DEFERRED:
                        _setattr(self, prop, value)
                else:
                    try:
                        opts.get_field(prop)
                    except FieldDoesNotExist:
                        unexpected += (prop,)
                    else:
                        if value is not _DEFERRED:
                            _setattr(self, prop, value)
            if unexpected:
                unexpected_names = ", ".join(repr(n) for n in unexpected)
>               raise TypeError(
                    f"{cls.__name__}() got unexpected keyword arguments: "
                    f"{unexpected_names}"
                )
E               TypeError: DocumentType() got unexpected keyword arguments: 'prefix'

/usr/local/lib/python3.11/site-packages/django/db/models/base.py:567: TypeError
___ ERROR at setup of TestApproverActions.test_approver_can_reject_document ____

self = <apps.workflows.tests.test_approval_workflow.TestApproverActions object at 0x7e0a005fa450>

    def setup_method(self):
        """Setup test data with document ready for approval"""
        self.client = APIClient()
    
        # Create users
        self.author = User.objects.create_user(
            username='test_author',
            password='test123'
        )
    
        self.approver = User.objects.create_user(
            username='test_approver',
            password='test123'
        )
    
        self.other_user = User.objects.create_user(
            username='other_user',
            password='test123'
        )
    
        # Assign approver role
        approver_role, _ = Role.objects.get_or_create(
            name='Document Approver',
            defaults={
                'module': 'S2',
                'permission_level': 'approver'
            }
        )
        UserRole.objects.create(
            user=self.approver,
            role=approver_role,
            is_active=True
        )
    
        # Create document type
>       self.doc_type = DocumentType.objects.create(
            code='TST',
            name='Test Document',
            prefix='TST'
        )

apps/workflows/tests/test_approval_workflow.py:157: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.11/site-packages/django/db/models/manager.py:87: in manager_method
    return getattr(self.get_queryset(), name)(*args, **kwargs)
/usr/local/lib/python3.11/site-packages/django/db/models/query.py:656: in create
    obj = self.model(**kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <DocumentType: Test Document (TST)>, args = ()
kwargs = {'prefix': 'TST'}, cls = <class 'apps.documents.models.DocumentType'>
opts = <Options for DocumentType>, _setattr = <built-in function setattr>
_DEFERRED = <Deferred field>
fields_iter = <tuple_iterator object at 0x7e09ffd6d3f0>, val = {}
field = <django.db.models.fields.json.JSONField: metadata>
is_related_object = False, property_names = frozenset({'pk'})

    def __init__(self, *args, **kwargs):
        # Alias some things as locals to avoid repeat global lookups
        cls = self.__class__
        opts = self._meta
        _setattr = setattr
        _DEFERRED = DEFERRED
        if opts.abstract:
            raise TypeError("Abstract models cannot be instantiated.")
    
        pre_init.send(sender=cls, args=args, kwargs=kwargs)
    
        # Set up the storage for instance state
        self._state = ModelState()
    
        # There is a rather weird disparity here; if kwargs, it's set, then args
        # overrides it. It should be one or the other; don't duplicate the work
        # The reason for the kwargs check is that standard iterator passes in by
        # args, and instantiation for iteration is 33% faster.
        if len(args) > len(opts.concrete_fields):
            # Daft, but matches old exception sans the err msg.
            raise IndexError("Number of args exceeds number of fields")
    
        if not kwargs:
            fields_iter = iter(opts.concrete_fields)
            # The ordering of the zip calls matter - zip throws StopIteration
            # when an iter throws it. So if the first iter throws it, the second
            # is *not* consumed. We rely on this, so don't change the order
            # without changing the logic.
            for val, field in zip(args, fields_iter):
                if val is _DEFERRED:
                    continue
                _setattr(self, field.attname, val)
        else:
            # Slower, kwargs-ready version.
            fields_iter = iter(opts.fields)
            for val, field in zip(args, fields_iter):
                if val is _DEFERRED:
                    continue
                _setattr(self, field.attname, val)
                if kwargs.pop(field.name, NOT_PROVIDED) is not NOT_PROVIDED:
                    raise TypeError(
                        f"{cls.__qualname__}() got both positional and "
                        f"keyword arguments for field '{field.name}'."
                    )
    
        # Now we're left with the unprocessed fields that *must* come from
        # keywords, or default.
    
        for field in fields_iter:
            is_related_object = False
            # Virtual field
            if field.attname not in kwargs and field.column is None:
                continue
            if kwargs:
                if isinstance(field.remote_field, ForeignObjectRel):
                    try:
                        # Assume object instance was passed in.
                        rel_obj = kwargs.pop(field.name)
                        is_related_object = True
                    except KeyError:
                        try:
                            # Object instance wasn't passed in -- must be an ID.
                            val = kwargs.pop(field.attname)
                        except KeyError:
                            val = field.get_default()
                else:
                    try:
                        val = kwargs.pop(field.attname)
                    except KeyError:
                        # This is done with an exception rather than the
                        # default argument on pop because we don't want
                        # get_default() to be evaluated, and then not used.
                        # Refs #12057.
                        val = field.get_default()
            else:
                val = field.get_default()
    
            if is_related_object:
                # If we are passed a related instance, set it using the
                # field.name instead of field.attname (e.g. "user" instead of
                # "user_id") so that the object gets properly cached (and type
                # checked) by the RelatedObjectDescriptor.
                if rel_obj is not _DEFERRED:
                    _setattr(self, field.name, rel_obj)
            else:
                if val is not _DEFERRED:
                    _setattr(self, field.attname, val)
    
        if kwargs:
            property_names = opts._property_names
            unexpected = ()
            for prop, value in kwargs.items():
                # Any remaining kwargs must correspond to properties or virtual
                # fields.
                if prop in property_names:
                    if value is not _DEFERRED:
                        _setattr(self, prop, value)
                else:
                    try:
                        opts.get_field(prop)
                    except FieldDoesNotExist:
                        unexpected += (prop,)
                    else:
                        if value is not _DEFERRED:
                            _setattr(self, prop, value)
            if unexpected:
                unexpected_names = ", ".join(repr(n) for n in unexpected)
>               raise TypeError(
                    f"{cls.__name__}() got unexpected keyword arguments: "
                    f"{unexpected_names}"
                )
E               TypeError: DocumentType() got unexpected keyword arguments: 'prefix'

/usr/local/lib/python3.11/site-packages/django/db/models/base.py:567: TypeError
_ ERROR at setup of TestApproverActions.test_non_approver_cannot_approve_document _

self = <apps.workflows.tests.test_approval_workflow.TestApproverActions object at 0x7e0a005f98d0>

    def setup_method(self):
        """Setup test data with document ready for approval"""
        self.client = APIClient()
    
        # Create users
        self.author = User.objects.create_user(
            username='test_author',
            password='test123'
        )
    
        self.approver = User.objects.create_user(
            username='test_approver',
            password='test123'
        )
    
        self.other_user = User.objects.create_user(
            username='other_user',
            password='test123'
        )
    
        # Assign approver role
        approver_role, _ = Role.objects.get_or_create(
            name='Document Approver',
            defaults={
                'module': 'S2',
                'permission_level': 'approver'
            }
        )
        UserRole.objects.create(
            user=self.approver,
            role=approver_role,
            is_active=True
        )
    
        # Create document type
>       self.doc_type = DocumentType.objects.create(
            code='TST',
            name='Test Document',
            prefix='TST'
        )

apps/workflows/tests/test_approval_workflow.py:157: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.11/site-packages/django/db/models/manager.py:87: in manager_method
    return getattr(self.get_queryset(), name)(*args, **kwargs)
/usr/local/lib/python3.11/site-packages/django/db/models/query.py:656: in create
    obj = self.model(**kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <DocumentType: Test Document (TST)>, args = ()
kwargs = {'prefix': 'TST'}, cls = <class 'apps.documents.models.DocumentType'>
opts = <Options for DocumentType>, _setattr = <built-in function setattr>
_DEFERRED = <Deferred field>
fields_iter = <tuple_iterator object at 0x7e09ffddfa30>, val = {}
field = <django.db.models.fields.json.JSONField: metadata>
is_related_object = False, property_names = frozenset({'pk'})

    def __init__(self, *args, **kwargs):
        # Alias some things as locals to avoid repeat global lookups
        cls = self.__class__
        opts = self._meta
        _setattr = setattr
        _DEFERRED = DEFERRED
        if opts.abstract:
            raise TypeError("Abstract models cannot be instantiated.")
    
        pre_init.send(sender=cls, args=args, kwargs=kwargs)
    
        # Set up the storage for instance state
        self._state = ModelState()
    
        # There is a rather weird disparity here; if kwargs, it's set, then args
        # overrides it. It should be one or the other; don't duplicate the work
        # The reason for the kwargs check is that standard iterator passes in by
        # args, and instantiation for iteration is 33% faster.
        if len(args) > len(opts.concrete_fields):
            # Daft, but matches old exception sans the err msg.
            raise IndexError("Number of args exceeds number of fields")
    
        if not kwargs:
            fields_iter = iter(opts.concrete_fields)
            # The ordering of the zip calls matter - zip throws StopIteration
            # when an iter throws it. So if the first iter throws it, the second
            # is *not* consumed. We rely on this, so don't change the order
            # without changing the logic.
            for val, field in zip(args, fields_iter):
                if val is _DEFERRED:
                    continue
                _setattr(self, field.attname, val)
        else:
            # Slower, kwargs-ready version.
            fields_iter = iter(opts.fields)
            for val, field in zip(args, fields_iter):
                if val is _DEFERRED:
                    continue
                _setattr(self, field.attname, val)
                if kwargs.pop(field.name, NOT_PROVIDED) is not NOT_PROVIDED:
                    raise TypeError(
                        f"{cls.__qualname__}() got both positional and "
                        f"keyword arguments for field '{field.name}'."
                    )
    
        # Now we're left with the unprocessed fields that *must* come from
        # keywords, or default.
    
        for field in fields_iter:
            is_related_object = False
            # Virtual field
            if field.attname not in kwargs and field.column is None:
                continue
            if kwargs:
                if isinstance(field.remote_field, ForeignObjectRel):
                    try:
                        # Assume object instance was passed in.
                        rel_obj = kwargs.pop(field.name)
                        is_related_object = True
                    except KeyError:
                        try:
                            # Object instance wasn't passed in -- must be an ID.
                            val = kwargs.pop(field.attname)
                        except KeyError:
                            val = field.get_default()
                else:
                    try:
                        val = kwargs.pop(field.attname)
                    except KeyError:
                        # This is done with an exception rather than the
                        # default argument on pop because we don't want
                        # get_default() to be evaluated, and then not used.
                        # Refs #12057.
                        val = field.get_default()
            else:
                val = field.get_default()
    
            if is_related_object:
                # If we are passed a related instance, set it using the
                # field.name instead of field.attname (e.g. "user" instead of
                # "user_id") so that the object gets properly cached (and type
                # checked) by the RelatedObjectDescriptor.
                if rel_obj is not _DEFERRED:
                    _setattr(self, field.name, rel_obj)
            else:
                if val is not _DEFERRED:
                    _setattr(self, field.attname, val)
    
        if kwargs:
            property_names = opts._property_names
            unexpected = ()
            for prop, value in kwargs.items():
                # Any remaining kwargs must correspond to properties or virtual
                # fields.
                if prop in property_names:
                    if value is not _DEFERRED:
                        _setattr(self, prop, value)
                else:
                    try:
                        opts.get_field(prop)
                    except FieldDoesNotExist:
                        unexpected += (prop,)
                    else:
                        if value is not _DEFERRED:
                            _setattr(self, prop, value)
            if unexpected:
                unexpected_names = ", ".join(repr(n) for n in unexpected)
>               raise TypeError(
                    f"{cls.__name__}() got unexpected keyword arguments: "
                    f"{unexpected_names}"
                )
E               TypeError: DocumentType() got unexpected keyword arguments: 'prefix'

/usr/local/lib/python3.11/site-packages/django/db/models/base.py:567: TypeError
_ ERROR at setup of TestApproverActions.test_approval_requires_effective_date __

self = <apps.workflows.tests.test_approval_workflow.TestApproverActions object at 0x7e0a005faad0>

    def setup_method(self):
        """Setup test data with document ready for approval"""
        self.client = APIClient()
    
        # Create users
        self.author = User.objects.create_user(
            username='test_author',
            password='test123'
        )
    
        self.approver = User.objects.create_user(
            username='test_approver',
            password='test123'
        )
    
        self.other_user = User.objects.create_user(
            username='other_user',
            password='test123'
        )
    
        # Assign approver role
        approver_role, _ = Role.objects.get_or_create(
            name='Document Approver',
            defaults={
                'module': 'S2',
                'permission_level': 'approver'
            }
        )
        UserRole.objects.create(
            user=self.approver,
            role=approver_role,
            is_active=True
        )
    
        # Create document type
>       self.doc_type = DocumentType.objects.create(
            code='TST',
            name='Test Document',
            prefix='TST'
        )

apps/workflows/tests/test_approval_workflow.py:157: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.11/site-packages/django/db/models/manager.py:87: in manager_method
    return getattr(self.get_queryset(), name)(*args, **kwargs)
/usr/local/lib/python3.11/site-packages/django/db/models/query.py:656: in create
    obj = self.model(**kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <DocumentType: Test Document (TST)>, args = ()
kwargs = {'prefix': 'TST'}, cls = <class 'apps.documents.models.DocumentType'>
opts = <Options for DocumentType>, _setattr = <built-in function setattr>
_DEFERRED = <Deferred field>
fields_iter = <tuple_iterator object at 0x7e0a00090a00>, val = {}
field = <django.db.models.fields.json.JSONField: metadata>
is_related_object = False, property_names = frozenset({'pk'})

    def __init__(self, *args, **kwargs):
        # Alias some things as locals to avoid repeat global lookups
        cls = self.__class__
        opts = self._meta
        _setattr = setattr
        _DEFERRED = DEFERRED
        if opts.abstract:
            raise TypeError("Abstract models cannot be instantiated.")
    
        pre_init.send(sender=cls, args=args, kwargs=kwargs)
    
        # Set up the storage for instance state
        self._state = ModelState()
    
        # There is a rather weird disparity here; if kwargs, it's set, then args
        # overrides it. It should be one or the other; don't duplicate the work
        # The reason for the kwargs check is that standard iterator passes in by
        # args, and instantiation for iteration is 33% faster.
        if len(args) > len(opts.concrete_fields):
            # Daft, but matches old exception sans the err msg.
            raise IndexError("Number of args exceeds number of fields")
    
        if not kwargs:
            fields_iter = iter(opts.concrete_fields)
            # The ordering of the zip calls matter - zip throws StopIteration
            # when an iter throws it. So if the first iter throws it, the second
            # is *not* consumed. We rely on this, so don't change the order
            # without changing the logic.
            for val, field in zip(args, fields_iter):
                if val is _DEFERRED:
                    continue
                _setattr(self, field.attname, val)
        else:
            # Slower, kwargs-ready version.
            fields_iter = iter(opts.fields)
            for val, field in zip(args, fields_iter):
                if val is _DEFERRED:
                    continue
                _setattr(self, field.attname, val)
                if kwargs.pop(field.name, NOT_PROVIDED) is not NOT_PROVIDED:
                    raise TypeError(
                        f"{cls.__qualname__}() got both positional and "
                        f"keyword arguments for field '{field.name}'."
                    )
    
        # Now we're left with the unprocessed fields that *must* come from
        # keywords, or default.
    
        for field in fields_iter:
            is_related_object = False
            # Virtual field
            if field.attname not in kwargs and field.column is None:
                continue
            if kwargs:
                if isinstance(field.remote_field, ForeignObjectRel):
                    try:
                        # Assume object instance was passed in.
                        rel_obj = kwargs.pop(field.name)
                        is_related_object = True
                    except KeyError:
                        try:
                            # Object instance wasn't passed in -- must be an ID.
                            val = kwargs.pop(field.attname)
                        except KeyError:
                            val = field.get_default()
                else:
                    try:
                        val = kwargs.pop(field.attname)
                    except KeyError:
                        # This is done with an exception rather than the
                        # default argument on pop because we don't want
                        # get_default() to be evaluated, and then not used.
                        # Refs #12057.
                        val = field.get_default()
            else:
                val = field.get_default()
    
            if is_related_object:
                # If we are passed a related instance, set it using the
                # field.name instead of field.attname (e.g. "user" instead of
                # "user_id") so that the object gets properly cached (and type
                # checked) by the RelatedObjectDescriptor.
                if rel_obj is not _DEFERRED:
                    _setattr(self, field.name, rel_obj)
            else:
                if val is not _DEFERRED:
                    _setattr(self, field.attname, val)
    
        if kwargs:
            property_names = opts._property_names
            unexpected = ()
            for prop, value in kwargs.items():
                # Any remaining kwargs must correspond to properties or virtual
                # fields.
                if prop in property_names:
                    if value is not _DEFERRED:
                        _setattr(self, prop, value)
                else:
                    try:
                        opts.get_field(prop)
                    except FieldDoesNotExist:
                        unexpected += (prop,)
                    else:
                        if value is not _DEFERRED:
                            _setattr(self, prop, value)
            if unexpected:
                unexpected_names = ", ".join(repr(n) for n in unexpected)
>               raise TypeError(
                    f"{cls.__name__}() got unexpected keyword arguments: "
                    f"{unexpected_names}"
                )
E               TypeError: DocumentType() got unexpected keyword arguments: 'prefix'

/usr/local/lib/python3.11/site-packages/django/db/models/base.py:567: TypeError
___ ERROR at setup of TestApproverActions.test_cannot_approve_draft_document ___

self = <apps.workflows.tests.test_approval_workflow.TestApproverActions object at 0x7e0a005fae10>

    def setup_method(self):
        """Setup test data with document ready for approval"""
        self.client = APIClient()
    
        # Create users
        self.author = User.objects.create_user(
            username='test_author',
            password='test123'
        )
    
        self.approver = User.objects.create_user(
            username='test_approver',
            password='test123'
        )
    
        self.other_user = User.objects.create_user(
            username='other_user',
            password='test123'
        )
    
        # Assign approver role
        approver_role, _ = Role.objects.get_or_create(
            name='Document Approver',
            defaults={
                'module': 'S2',
                'permission_level': 'approver'
            }
        )
        UserRole.objects.create(
            user=self.approver,
            role=approver_role,
            is_active=True
        )
    
        # Create document type
>       self.doc_type = DocumentType.objects.create(
            code='TST',
            name='Test Document',
            prefix='TST'
        )

apps/workflows/tests/test_approval_workflow.py:157: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.11/site-packages/django/db/models/manager.py:87: in manager_method
    return getattr(self.get_queryset(), name)(*args, **kwargs)
/usr/local/lib/python3.11/site-packages/django/db/models/query.py:656: in create
    obj = self.model(**kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <DocumentType: Test Document (TST)>, args = ()
kwargs = {'prefix': 'TST'}, cls = <class 'apps.documents.models.DocumentType'>
opts = <Options for DocumentType>, _setattr = <built-in function setattr>
_DEFERRED = <Deferred field>
fields_iter = <tuple_iterator object at 0x7e09ffdf88e0>, val = {}
field = <django.db.models.fields.json.JSONField: metadata>
is_related_object = False, property_names = frozenset({'pk'})

    def __init__(self, *args, **kwargs):
        # Alias some things as locals to avoid repeat global lookups
        cls = self.__class__
        opts = self._meta
        _setattr = setattr
        _DEFERRED = DEFERRED
        if opts.abstract:
            raise TypeError("Abstract models cannot be instantiated.")
    
        pre_init.send(sender=cls, args=args, kwargs=kwargs)
    
        # Set up the storage for instance state
        self._state = ModelState()
    
        # There is a rather weird disparity here; if kwargs, it's set, then args
        # overrides it. It should be one or the other; don't duplicate the work
        # The reason for the kwargs check is that standard iterator passes in by
        # args, and instantiation for iteration is 33% faster.
        if len(args) > len(opts.concrete_fields):
            # Daft, but matches old exception sans the err msg.
            raise IndexError("Number of args exceeds number of fields")
    
        if not kwargs:
            fields_iter = iter(opts.concrete_fields)
            # The ordering of the zip calls matter - zip throws StopIteration
            # when an iter throws it. So if the first iter throws it, the second
            # is *not* consumed. We rely on this, so don't change the order
            # without changing the logic.
            for val, field in zip(args, fields_iter):
                if val is _DEFERRED:
                    continue
                _setattr(self, field.attname, val)
        else:
            # Slower, kwargs-ready version.
            fields_iter = iter(opts.fields)
            for val, field in zip(args, fields_iter):
                if val is _DEFERRED:
                    continue
                _setattr(self, field.attname, val)
                if kwargs.pop(field.name, NOT_PROVIDED) is not NOT_PROVIDED:
                    raise TypeError(
                        f"{cls.__qualname__}() got both positional and "
                        f"keyword arguments for field '{field.name}'."
                    )
    
        # Now we're left with the unprocessed fields that *must* come from
        # keywords, or default.
    
        for field in fields_iter:
            is_related_object = False
            # Virtual field
            if field.attname not in kwargs and field.column is None:
                continue
            if kwargs:
                if isinstance(field.remote_field, ForeignObjectRel):
                    try:
                        # Assume object instance was passed in.
                        rel_obj = kwargs.pop(field.name)
                        is_related_object = True
                    except KeyError:
                        try:
                            # Object instance wasn't passed in -- must be an ID.
                            val = kwargs.pop(field.attname)
                        except KeyError:
                            val = field.get_default()
                else:
                    try:
                        val = kwargs.pop(field.attname)
                    except KeyError:
                        # This is done with an exception rather than the
                        # default argument on pop because we don't want
                        # get_default() to be evaluated, and then not used.
                        # Refs #12057.
                        val = field.get_default()
            else:
                val = field.get_default()
    
            if is_related_object:
                # If we are passed a related instance, set it using the
                # field.name instead of field.attname (e.g. "user" instead of
                # "user_id") so that the object gets properly cached (and type
                # checked) by the RelatedObjectDescriptor.
                if rel_obj is not _DEFERRED:
                    _setattr(self, field.name, rel_obj)
            else:
                if val is not _DEFERRED:
                    _setattr(self, field.attname, val)
    
        if kwargs:
            property_names = opts._property_names
            unexpected = ()
            for prop, value in kwargs.items():
                # Any remaining kwargs must correspond to properties or virtual
                # fields.
                if prop in property_names:
                    if value is not _DEFERRED:
                        _setattr(self, prop, value)
                else:
                    try:
                        opts.get_field(prop)
                    except FieldDoesNotExist:
                        unexpected += (prop,)
                    else:
                        if value is not _DEFERRED:
                            _setattr(self, prop, value)
            if unexpected:
                unexpected_names = ", ".join(repr(n) for n in unexpected)
>               raise TypeError(
                    f"{cls.__name__}() got unexpected keyword arguments: "
                    f"{unexpected_names}"
                )
E               TypeError: DocumentType() got unexpected keyword arguments: 'prefix'

/usr/local/lib/python3.11/site-packages/django/db/models/base.py:567: TypeError
_ ERROR at setup of TestApproverActions.test_effective_date_cannot_be_in_past __

self = <apps.workflows.tests.test_approval_workflow.TestApproverActions object at 0x7e0a005fb490>

    def setup_method(self):
        """Setup test data with document ready for approval"""
        self.client = APIClient()
    
        # Create users
        self.author = User.objects.create_user(
            username='test_author',
            password='test123'
        )
    
        self.approver = User.objects.create_user(
            username='test_approver',
            password='test123'
        )
    
        self.other_user = User.objects.create_user(
            username='other_user',
            password='test123'
        )
    
        # Assign approver role
        approver_role, _ = Role.objects.get_or_create(
            name='Document Approver',
            defaults={
                'module': 'S2',
                'permission_level': 'approver'
            }
        )
        UserRole.objects.create(
            user=self.approver,
            role=approver_role,
            is_active=True
        )
    
        # Create document type
>       self.doc_type = DocumentType.objects.create(
            code='TST',
            name='Test Document',
            prefix='TST'
        )

apps/workflows/tests/test_approval_workflow.py:157: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.11/site-packages/django/db/models/manager.py:87: in manager_method
    return getattr(self.get_queryset(), name)(*args, **kwargs)
/usr/local/lib/python3.11/site-packages/django/db/models/query.py:656: in create
    obj = self.model(**kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <DocumentType: Test Document (TST)>, args = ()
kwargs = {'prefix': 'TST'}, cls = <class 'apps.documents.models.DocumentType'>
opts = <Options for DocumentType>, _setattr = <built-in function setattr>
_DEFERRED = <Deferred field>
fields_iter = <tuple_iterator object at 0x7e09ffd8eec0>, val = {}
field = <django.db.models.fields.json.JSONField: metadata>
is_related_object = False, property_names = frozenset({'pk'})

    def __init__(self, *args, **kwargs):
        # Alias some things as locals to avoid repeat global lookups
        cls = self.__class__
        opts = self._meta
        _setattr = setattr
        _DEFERRED = DEFERRED
        if opts.abstract:
            raise TypeError("Abstract models cannot be instantiated.")
    
        pre_init.send(sender=cls, args=args, kwargs=kwargs)
    
        # Set up the storage for instance state
        self._state = ModelState()
    
        # There is a rather weird disparity here; if kwargs, it's set, then args
        # overrides it. It should be one or the other; don't duplicate the work
        # The reason for the kwargs check is that standard iterator passes in by
        # args, and instantiation for iteration is 33% faster.
        if len(args) > len(opts.concrete_fields):
            # Daft, but matches old exception sans the err msg.
            raise IndexError("Number of args exceeds number of fields")
    
        if not kwargs:
            fields_iter = iter(opts.concrete_fields)
            # The ordering of the zip calls matter - zip throws StopIteration
            # when an iter throws it. So if the first iter throws it, the second
            # is *not* consumed. We rely on this, so don't change the order
            # without changing the logic.
            for val, field in zip(args, fields_iter):
                if val is _DEFERRED:
                    continue
                _setattr(self, field.attname, val)
        else:
            # Slower, kwargs-ready version.
            fields_iter = iter(opts.fields)
            for val, field in zip(args, fields_iter):
                if val is _DEFERRED:
                    continue
                _setattr(self, field.attname, val)
                if kwargs.pop(field.name, NOT_PROVIDED) is not NOT_PROVIDED:
                    raise TypeError(
                        f"{cls.__qualname__}() got both positional and "
                        f"keyword arguments for field '{field.name}'."
                    )
    
        # Now we're left with the unprocessed fields that *must* come from
        # keywords, or default.
    
        for field in fields_iter:
            is_related_object = False
            # Virtual field
            if field.attname not in kwargs and field.column is None:
                continue
            if kwargs:
                if isinstance(field.remote_field, ForeignObjectRel):
                    try:
                        # Assume object instance was passed in.
                        rel_obj = kwargs.pop(field.name)
                        is_related_object = True
                    except KeyError:
                        try:
                            # Object instance wasn't passed in -- must be an ID.
                            val = kwargs.pop(field.attname)
                        except KeyError:
                            val = field.get_default()
                else:
                    try:
                        val = kwargs.pop(field.attname)
                    except KeyError:
                        # This is done with an exception rather than the
                        # default argument on pop because we don't want
                        # get_default() to be evaluated, and then not used.
                        # Refs #12057.
                        val = field.get_default()
            else:
                val = field.get_default()
    
            if is_related_object:
                # If we are passed a related instance, set it using the
                # field.name instead of field.attname (e.g. "user" instead of
                # "user_id") so that the object gets properly cached (and type
                # checked) by the RelatedObjectDescriptor.
                if rel_obj is not _DEFERRED:
                    _setattr(self, field.name, rel_obj)
            else:
                if val is not _DEFERRED:
                    _setattr(self, field.attname, val)
    
        if kwargs:
            property_names = opts._property_names
            unexpected = ()
            for prop, value in kwargs.items():
                # Any remaining kwargs must correspond to properties or virtual
                # fields.
                if prop in property_names:
                    if value is not _DEFERRED:
                        _setattr(self, prop, value)
                else:
                    try:
                        opts.get_field(prop)
                    except FieldDoesNotExist:
                        unexpected += (prop,)
                    else:
                        if value is not _DEFERRED:
                            _setattr(self, prop, value)
            if unexpected:
                unexpected_names = ", ".join(repr(n) for n in unexpected)
>               raise TypeError(
                    f"{cls.__name__}() got unexpected keyword arguments: "
                    f"{unexpected_names}"
                )
E               TypeError: DocumentType() got unexpected keyword arguments: 'prefix'

/usr/local/lib/python3.11/site-packages/django/db/models/base.py:567: TypeError
_ ERROR at setup of TestAutomaticEffectiveActivation.test_document_becomes_effective_on_scheduled_date _

self = <apps.workflows.tests.test_approval_workflow.TestAutomaticEffectiveActivation object at 0x7e0a005fbe10>

    def setup_method(self):
        """Setup test data"""
        self.client = APIClient()
    
        # Create user
        self.author = User.objects.create_user(
            username='test_author',
            password='test123'
        )
    
        # Create document type
>       self.doc_type = DocumentType.objects.create(
            code='TST',
            name='Test Document',
            prefix='TST'
        )

apps/workflows/tests/test_approval_workflow.py:348: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.11/site-packages/django/db/models/manager.py:87: in manager_method
    return getattr(self.get_queryset(), name)(*args, **kwargs)
/usr/local/lib/python3.11/site-packages/django/db/models/query.py:656: in create
    obj = self.model(**kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <DocumentType: Test Document (TST)>, args = ()
kwargs = {'prefix': 'TST'}, cls = <class 'apps.documents.models.DocumentType'>
opts = <Options for DocumentType>, _setattr = <built-in function setattr>
_DEFERRED = <Deferred field>
fields_iter = <tuple_iterator object at 0x7e09ffd6cfd0>, val = {}
field = <django.db.models.fields.json.JSONField: metadata>
is_related_object = False, property_names = frozenset({'pk'})

    def __init__(self, *args, **kwargs):
        # Alias some things as locals to avoid repeat global lookups
        cls = self.__class__
        opts = self._meta
        _setattr = setattr
        _DEFERRED = DEFERRED
        if opts.abstract:
            raise TypeError("Abstract models cannot be instantiated.")
    
        pre_init.send(sender=cls, args=args, kwargs=kwargs)
    
        # Set up the storage for instance state
        self._state = ModelState()
    
        # There is a rather weird disparity here; if kwargs, it's set, then args
        # overrides it. It should be one or the other; don't duplicate the work
        # The reason for the kwargs check is that standard iterator passes in by
        # args, and instantiation for iteration is 33% faster.
        if len(args) > len(opts.concrete_fields):
            # Daft, but matches old exception sans the err msg.
            raise IndexError("Number of args exceeds number of fields")
    
        if not kwargs:
            fields_iter = iter(opts.concrete_fields)
            # The ordering of the zip calls matter - zip throws StopIteration
            # when an iter throws it. So if the first iter throws it, the second
            # is *not* consumed. We rely on this, so don't change the order
            # without changing the logic.
            for val, field in zip(args, fields_iter):
                if val is _DEFERRED:
                    continue
                _setattr(self, field.attname, val)
        else:
            # Slower, kwargs-ready version.
            fields_iter = iter(opts.fields)
            for val, field in zip(args, fields_iter):
                if val is _DEFERRED:
                    continue
                _setattr(self, field.attname, val)
                if kwargs.pop(field.name, NOT_PROVIDED) is not NOT_PROVIDED:
                    raise TypeError(
                        f"{cls.__qualname__}() got both positional and "
                        f"keyword arguments for field '{field.name}'."
                    )
    
        # Now we're left with the unprocessed fields that *must* come from
        # keywords, or default.
    
        for field in fields_iter:
            is_related_object = False
            # Virtual field
            if field.attname not in kwargs and field.column is None:
                continue
            if kwargs:
                if isinstance(field.remote_field, ForeignObjectRel):
                    try:
                        # Assume object instance was passed in.
                        rel_obj = kwargs.pop(field.name)
                        is_related_object = True
                    except KeyError:
                        try:
                            # Object instance wasn't passed in -- must be an ID.
                            val = kwargs.pop(field.attname)
                        except KeyError:
                            val = field.get_default()
                else:
                    try:
                        val = kwargs.pop(field.attname)
                    except KeyError:
                        # This is done with an exception rather than the
                        # default argument on pop because we don't want
                        # get_default() to be evaluated, and then not used.
                        # Refs #12057.
                        val = field.get_default()
            else:
                val = field.get_default()
    
            if is_related_object:
                # If we are passed a related instance, set it using the
                # field.name instead of field.attname (e.g. "user" instead of
                # "user_id") so that the object gets properly cached (and type
                # checked) by the RelatedObjectDescriptor.
                if rel_obj is not _DEFERRED:
                    _setattr(self, field.name, rel_obj)
            else:
                if val is not _DEFERRED:
                    _setattr(self, field.attname, val)
    
        if kwargs:
            property_names = opts._property_names
            unexpected = ()
            for prop, value in kwargs.items():
                # Any remaining kwargs must correspond to properties or virtual
                # fields.
                if prop in property_names:
                    if value is not _DEFERRED:
                        _setattr(self, prop, value)
                else:
                    try:
                        opts.get_field(prop)
                    except FieldDoesNotExist:
                        unexpected += (prop,)
                    else:
                        if value is not _DEFERRED:
                            _setattr(self, prop, value)
            if unexpected:
                unexpected_names = ", ".join(repr(n) for n in unexpected)
>               raise TypeError(
                    f"{cls.__name__}() got unexpected keyword arguments: "
                    f"{unexpected_names}"
                )
E               TypeError: DocumentType() got unexpected keyword arguments: 'prefix'

/usr/local/lib/python3.11/site-packages/django/db/models/base.py:567: TypeError
_ ERROR at setup of TestAutomaticEffectiveActivation.test_future_dated_documents_remain_pending _

self = <apps.workflows.tests.test_approval_workflow.TestAutomaticEffectiveActivation object at 0x7e0a004084d0>

    def setup_method(self):
        """Setup test data"""
        self.client = APIClient()
    
        # Create user
        self.author = User.objects.create_user(
            username='test_author',
            password='test123'
        )
    
        # Create document type
>       self.doc_type = DocumentType.objects.create(
            code='TST',
            name='Test Document',
            prefix='TST'
        )

apps/workflows/tests/test_approval_workflow.py:348: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.11/site-packages/django/db/models/manager.py:87: in manager_method
    return getattr(self.get_queryset(), name)(*args, **kwargs)
/usr/local/lib/python3.11/site-packages/django/db/models/query.py:656: in create
    obj = self.model(**kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <DocumentType: Test Document (TST)>, args = ()
kwargs = {'prefix': 'TST'}, cls = <class 'apps.documents.models.DocumentType'>
opts = <Options for DocumentType>, _setattr = <built-in function setattr>
_DEFERRED = <Deferred field>
fields_iter = <tuple_iterator object at 0x7e09ffddcf40>, val = {}
field = <django.db.models.fields.json.JSONField: metadata>
is_related_object = False, property_names = frozenset({'pk'})

    def __init__(self, *args, **kwargs):
        # Alias some things as locals to avoid repeat global lookups
        cls = self.__class__
        opts = self._meta
        _setattr = setattr
        _DEFERRED = DEFERRED
        if opts.abstract:
            raise TypeError("Abstract models cannot be instantiated.")
    
        pre_init.send(sender=cls, args=args, kwargs=kwargs)
    
        # Set up the storage for instance state
        self._state = ModelState()
    
        # There is a rather weird disparity here; if kwargs, it's set, then args
        # overrides it. It should be one or the other; don't duplicate the work
        # The reason for the kwargs check is that standard iterator passes in by
        # args, and instantiation for iteration is 33% faster.
        if len(args) > len(opts.concrete_fields):
            # Daft, but matches old exception sans the err msg.
            raise IndexError("Number of args exceeds number of fields")
    
        if not kwargs:
            fields_iter = iter(opts.concrete_fields)
            # The ordering of the zip calls matter - zip throws StopIteration
            # when an iter throws it. So if the first iter throws it, the second
            # is *not* consumed. We rely on this, so don't change the order
            # without changing the logic.
            for val, field in zip(args, fields_iter):
                if val is _DEFERRED:
                    continue
                _setattr(self, field.attname, val)
        else:
            # Slower, kwargs-ready version.
            fields_iter = iter(opts.fields)
            for val, field in zip(args, fields_iter):
                if val is _DEFERRED:
                    continue
                _setattr(self, field.attname, val)
                if kwargs.pop(field.name, NOT_PROVIDED) is not NOT_PROVIDED:
                    raise TypeError(
                        f"{cls.__qualname__}() got both positional and "
                        f"keyword arguments for field '{field.name}'."
                    )
    
        # Now we're left with the unprocessed fields that *must* come from
        # keywords, or default.
    
        for field in fields_iter:
            is_related_object = False
            # Virtual field
            if field.attname not in kwargs and field.column is None:
                continue
            if kwargs:
                if isinstance(field.remote_field, ForeignObjectRel):
                    try:
                        # Assume object instance was passed in.
                        rel_obj = kwargs.pop(field.name)
                        is_related_object = True
                    except KeyError:
                        try:
                            # Object instance wasn't passed in -- must be an ID.
                            val = kwargs.pop(field.attname)
                        except KeyError:
                            val = field.get_default()
                else:
                    try:
                        val = kwargs.pop(field.attname)
                    except KeyError:
                        # This is done with an exception rather than the
                        # default argument on pop because we don't want
                        # get_default() to be evaluated, and then not used.
                        # Refs #12057.
                        val = field.get_default()
            else:
                val = field.get_default()
    
            if is_related_object:
                # If we are passed a related instance, set it using the
                # field.name instead of field.attname (e.g. "user" instead of
                # "user_id") so that the object gets properly cached (and type
                # checked) by the RelatedObjectDescriptor.
                if rel_obj is not _DEFERRED:
                    _setattr(self, field.name, rel_obj)
            else:
                if val is not _DEFERRED:
                    _setattr(self, field.attname, val)
    
        if kwargs:
            property_names = opts._property_names
            unexpected = ()
            for prop, value in kwargs.items():
                # Any remaining kwargs must correspond to properties or virtual
                # fields.
                if prop in property_names:
                    if value is not _DEFERRED:
                        _setattr(self, prop, value)
                else:
                    try:
                        opts.get_field(prop)
                    except FieldDoesNotExist:
                        unexpected += (prop,)
                    else:
                        if value is not _DEFERRED:
                            _setattr(self, prop, value)
            if unexpected:
                unexpected_names = ", ".join(repr(n) for n in unexpected)
>               raise TypeError(
                    f"{cls.__name__}() got unexpected keyword arguments: "
                    f"{unexpected_names}"
                )
E               TypeError: DocumentType() got unexpected keyword arguments: 'prefix'

/usr/local/lib/python3.11/site-packages/django/db/models/base.py:567: TypeError
_ ERROR at setup of TestDocumentObsolescence.test_approver_can_mark_document_obsolete _

self = <apps.workflows.tests.test_obsolescence_workflow.TestDocumentObsolescence object at 0x7e0a00468f90>

    def setup_method(self):
        """Setup test data before each test"""
        # Create users
        self.author = User.objects.create_user(
            username='author_obs',
            password='test123'
        )
        self.approver = User.objects.create_user(
            username='approver_obs',
            password='test123'
        )
        self.regular_user = User.objects.create_user(
            username='user_obs',
            password='test123'
        )
    
        # Create WorkflowType objects (REQUIRED for lifecycle service)
        self.review_workflow_type = WorkflowType.objects.create(
            name='Document Review',
            workflow_type='REVIEW',
            created_by=self.author
        )
        self.approval_workflow_type = WorkflowType.objects.create(
            name='Document Approval',
            workflow_type='APPROVAL',
            created_by=self.author
        )
    
        # Create DocumentState objects (REQUIRED for workflow transitions)
        for code, name in [
            ('DRAFT', 'Draft'),
            ('UNDER_REVIEW', 'Under Review'),
            ('REVIEW_COMPLETED', 'Review Completed'),
            ('PENDING_APPROVAL', 'Pending Approval'),
            ('APPROVED_PENDING_EFFECTIVE', 'Approved Pending Effective'),
            ('EFFECTIVE', 'Effective'),
            ('SCHEDULED_FOR_OBSOLESCENCE', 'Scheduled for Obsolescence'),
            ('OBSOLETE', 'Obsolete'),
        ]:
>           DocumentState.objects.create(
                name=name,
                code=code
            )
E           NameError: name 'DocumentState' is not defined

apps/workflows/tests/test_obsolescence_workflow.py:70: NameError
_ ERROR at setup of TestDocumentObsolescence.test_obsolescence_requires_reason _

self = <apps.workflows.tests.test_obsolescence_workflow.TestDocumentObsolescence object at 0x7e0a0046a890>

    def setup_method(self):
        """Setup test data before each test"""
        # Create users
        self.author = User.objects.create_user(
            username='author_obs',
            password='test123'
        )
        self.approver = User.objects.create_user(
            username='approver_obs',
            password='test123'
        )
        self.regular_user = User.objects.create_user(
            username='user_obs',
            password='test123'
        )
    
        # Create WorkflowType objects (REQUIRED for lifecycle service)
        self.review_workflow_type = WorkflowType.objects.create(
            name='Document Review',
            workflow_type='REVIEW',
            created_by=self.author
        )
        self.approval_workflow_type = WorkflowType.objects.create(
            name='Document Approval',
            workflow_type='APPROVAL',
            created_by=self.author
        )
    
        # Create DocumentState objects (REQUIRED for workflow transitions)
        for code, name in [
            ('DRAFT', 'Draft'),
            ('UNDER_REVIEW', 'Under Review'),
            ('REVIEW_COMPLETED', 'Review Completed'),
            ('PENDING_APPROVAL', 'Pending Approval'),
            ('APPROVED_PENDING_EFFECTIVE', 'Approved Pending Effective'),
            ('EFFECTIVE', 'Effective'),
            ('SCHEDULED_FOR_OBSOLESCENCE', 'Scheduled for Obsolescence'),
            ('OBSOLETE', 'Obsolete'),
        ]:
>           DocumentState.objects.create(
                name=name,
                code=code
            )
E           NameError: name 'DocumentState' is not defined

apps/workflows/tests/test_obsolescence_workflow.py:70: NameError
_ ERROR at setup of TestDocumentObsolescence.test_scheduled_obsolescence_date __

self = <apps.workflows.tests.test_obsolescence_workflow.TestDocumentObsolescence object at 0x7e0a00469650>

    def setup_method(self):
        """Setup test data before each test"""
        # Create users
        self.author = User.objects.create_user(
            username='author_obs',
            password='test123'
        )
        self.approver = User.objects.create_user(
            username='approver_obs',
            password='test123'
        )
        self.regular_user = User.objects.create_user(
            username='user_obs',
            password='test123'
        )
    
        # Create WorkflowType objects (REQUIRED for lifecycle service)
        self.review_workflow_type = WorkflowType.objects.create(
            name='Document Review',
            workflow_type='REVIEW',
            created_by=self.author
        )
        self.approval_workflow_type = WorkflowType.objects.create(
            name='Document Approval',
            workflow_type='APPROVAL',
            created_by=self.author
        )
    
        # Create DocumentState objects (REQUIRED for workflow transitions)
        for code, name in [
            ('DRAFT', 'Draft'),
            ('UNDER_REVIEW', 'Under Review'),
            ('REVIEW_COMPLETED', 'Review Completed'),
            ('PENDING_APPROVAL', 'Pending Approval'),
            ('APPROVED_PENDING_EFFECTIVE', 'Approved Pending Effective'),
            ('EFFECTIVE', 'Effective'),
            ('SCHEDULED_FOR_OBSOLESCENCE', 'Scheduled for Obsolescence'),
            ('OBSOLETE', 'Obsolete'),
        ]:
>           DocumentState.objects.create(
                name=name,
                code=code
            )
E           NameError: name 'DocumentState' is not defined

apps/workflows/tests/test_obsolescence_workflow.py:70: NameError
____ ERROR at setup of TestDocumentObsolescence.test_immediate_obsolescence ____

self = <apps.workflows.tests.test_obsolescence_workflow.TestDocumentObsolescence object at 0x7e0a00469b10>

    def setup_method(self):
        """Setup test data before each test"""
        # Create users
        self.author = User.objects.create_user(
            username='author_obs',
            password='test123'
        )
        self.approver = User.objects.create_user(
            username='approver_obs',
            password='test123'
        )
        self.regular_user = User.objects.create_user(
            username='user_obs',
            password='test123'
        )
    
        # Create WorkflowType objects (REQUIRED for lifecycle service)
        self.review_workflow_type = WorkflowType.objects.create(
            name='Document Review',
            workflow_type='REVIEW',
            created_by=self.author
        )
        self.approval_workflow_type = WorkflowType.objects.create(
            name='Document Approval',
            workflow_type='APPROVAL',
            created_by=self.author
        )
    
        # Create DocumentState objects (REQUIRED for workflow transitions)
        for code, name in [
            ('DRAFT', 'Draft'),
            ('UNDER_REVIEW', 'Under Review'),
            ('REVIEW_COMPLETED', 'Review Completed'),
            ('PENDING_APPROVAL', 'Pending Approval'),
            ('APPROVED_PENDING_EFFECTIVE', 'Approved Pending Effective'),
            ('EFFECTIVE', 'Effective'),
            ('SCHEDULED_FOR_OBSOLESCENCE', 'Scheduled for Obsolescence'),
            ('OBSOLETE', 'Obsolete'),
        ]:
>           DocumentState.objects.create(
                name=name,
                code=code
            )
E           NameError: name 'DocumentState' is not defined

apps/workflows/tests/test_obsolescence_workflow.py:70: NameError
_ ERROR at setup of TestDocumentObsolescence.test_cannot_obsolete_non_effective_document _

self = <apps.workflows.tests.test_obsolescence_workflow.TestDocumentObsolescence object at 0x7e0a0046a090>

    def setup_method(self):
        """Setup test data before each test"""
        # Create users
        self.author = User.objects.create_user(
            username='author_obs',
            password='test123'
        )
        self.approver = User.objects.create_user(
            username='approver_obs',
            password='test123'
        )
        self.regular_user = User.objects.create_user(
            username='user_obs',
            password='test123'
        )
    
        # Create WorkflowType objects (REQUIRED for lifecycle service)
        self.review_workflow_type = WorkflowType.objects.create(
            name='Document Review',
            workflow_type='REVIEW',
            created_by=self.author
        )
        self.approval_workflow_type = WorkflowType.objects.create(
            name='Document Approval',
            workflow_type='APPROVAL',
            created_by=self.author
        )
    
        # Create DocumentState objects (REQUIRED for workflow transitions)
        for code, name in [
            ('DRAFT', 'Draft'),
            ('UNDER_REVIEW', 'Under Review'),
            ('REVIEW_COMPLETED', 'Review Completed'),
            ('PENDING_APPROVAL', 'Pending Approval'),
            ('APPROVED_PENDING_EFFECTIVE', 'Approved Pending Effective'),
            ('EFFECTIVE', 'Effective'),
            ('SCHEDULED_FOR_OBSOLESCENCE', 'Scheduled for Obsolescence'),
            ('OBSOLETE', 'Obsolete'),
        ]:
>           DocumentState.objects.create(
                name=name,
                code=code
            )
E           NameError: name 'DocumentState' is not defined

apps/workflows/tests/test_obsolescence_workflow.py:70: NameError
_ ERROR at setup of TestDocumentObsolescence.test_author_cannot_mark_obsolete __

self = <apps.workflows.tests.test_obsolescence_workflow.TestDocumentObsolescence object at 0x7e0a00469f90>

    def setup_method(self):
        """Setup test data before each test"""
        # Create users
        self.author = User.objects.create_user(
            username='author_obs',
            password='test123'
        )
        self.approver = User.objects.create_user(
            username='approver_obs',
            password='test123'
        )
        self.regular_user = User.objects.create_user(
            username='user_obs',
            password='test123'
        )
    
        # Create WorkflowType objects (REQUIRED for lifecycle service)
        self.review_workflow_type = WorkflowType.objects.create(
            name='Document Review',
            workflow_type='REVIEW',
            created_by=self.author
        )
        self.approval_workflow_type = WorkflowType.objects.create(
            name='Document Approval',
            workflow_type='APPROVAL',
            created_by=self.author
        )
    
        # Create DocumentState objects (REQUIRED for workflow transitions)
        for code, name in [
            ('DRAFT', 'Draft'),
            ('UNDER_REVIEW', 'Under Review'),
            ('REVIEW_COMPLETED', 'Review Completed'),
            ('PENDING_APPROVAL', 'Pending Approval'),
            ('APPROVED_PENDING_EFFECTIVE', 'Approved Pending Effective'),
            ('EFFECTIVE', 'Effective'),
            ('SCHEDULED_FOR_OBSOLESCENCE', 'Scheduled for Obsolescence'),
            ('OBSOLETE', 'Obsolete'),
        ]:
>           DocumentState.objects.create(
                name=name,
                code=code
            )
E           NameError: name 'DocumentState' is not defined

apps/workflows/tests/test_obsolescence_workflow.py:70: NameError
_ ERROR at setup of TestDocumentObsolescence.test_obsolete_documents_are_read_only _

self = <apps.workflows.tests.test_obsolescence_workflow.TestDocumentObsolescence object at 0x7e0a0046b110>

    def setup_method(self):
        """Setup test data before each test"""
        # Create users
        self.author = User.objects.create_user(
            username='author_obs',
            password='test123'
        )
        self.approver = User.objects.create_user(
            username='approver_obs',
            password='test123'
        )
        self.regular_user = User.objects.create_user(
            username='user_obs',
            password='test123'
        )
    
        # Create WorkflowType objects (REQUIRED for lifecycle service)
        self.review_workflow_type = WorkflowType.objects.create(
            name='Document Review',
            workflow_type='REVIEW',
            created_by=self.author
        )
        self.approval_workflow_type = WorkflowType.objects.create(
            name='Document Approval',
            workflow_type='APPROVAL',
            created_by=self.author
        )
    
        # Create DocumentState objects (REQUIRED for workflow transitions)
        for code, name in [
            ('DRAFT', 'Draft'),
            ('UNDER_REVIEW', 'Under Review'),
            ('REVIEW_COMPLETED', 'Review Completed'),
            ('PENDING_APPROVAL', 'Pending Approval'),
            ('APPROVED_PENDING_EFFECTIVE', 'Approved Pending Effective'),
            ('EFFECTIVE', 'Effective'),
            ('SCHEDULED_FOR_OBSOLESCENCE', 'Scheduled for Obsolescence'),
            ('OBSOLETE', 'Obsolete'),
        ]:
>           DocumentState.objects.create(
                name=name,
                code=code
            )
E           NameError: name 'DocumentState' is not defined

apps/workflows/tests/test_obsolescence_workflow.py:70: NameError
_ ERROR at setup of TestSubmitForReview.test_author_can_submit_document_for_review _

self = <apps.workflows.tests.test_review_workflow.TestSubmitForReview object at 0x7e0a00426c90>

    def setup_method(self):
        """Setup test data"""
        self.client = APIClient()
    
        # Create users
        self.author = User.objects.create_user(
            username='test_author',
            password='test123',
            email='author@test.com'
        )
    
        self.reviewer = User.objects.create_user(
            username='test_reviewer',
            password='test123',
            email='reviewer@test.com'
        )
    
        # Assign reviewer role
        reviewer_role, _ = Role.objects.get_or_create(
            name='Document Reviewer',
            defaults={
                'module': 'S2',
                'permission_level': 'reviewer'
            }
        )
        UserRole.objects.create(
            user=self.reviewer,
            role=reviewer_role,
            is_active=True
        )
    
        # Create document type and source
>       self.doc_type = DocumentType.objects.create(
            code='TST',
            name='Test Document',
            prefix='TST'
        )

apps/workflows/tests/test_review_workflow.py:59: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.11/site-packages/django/db/models/manager.py:87: in manager_method
    return getattr(self.get_queryset(), name)(*args, **kwargs)
/usr/local/lib/python3.11/site-packages/django/db/models/query.py:656: in create
    obj = self.model(**kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <DocumentType: Test Document (TST)>, args = ()
kwargs = {'prefix': 'TST'}, cls = <class 'apps.documents.models.DocumentType'>
opts = <Options for DocumentType>, _setattr = <built-in function setattr>
_DEFERRED = <Deferred field>
fields_iter = <tuple_iterator object at 0x7e09ffb4f640>, val = {}
field = <django.db.models.fields.json.JSONField: metadata>
is_related_object = False, property_names = frozenset({'pk'})

    def __init__(self, *args, **kwargs):
        # Alias some things as locals to avoid repeat global lookups
        cls = self.__class__
        opts = self._meta
        _setattr = setattr
        _DEFERRED = DEFERRED
        if opts.abstract:
            raise TypeError("Abstract models cannot be instantiated.")
    
        pre_init.send(sender=cls, args=args, kwargs=kwargs)
    
        # Set up the storage for instance state
        self._state = ModelState()
    
        # There is a rather weird disparity here; if kwargs, it's set, then args
        # overrides it. It should be one or the other; don't duplicate the work
        # The reason for the kwargs check is that standard iterator passes in by
        # args, and instantiation for iteration is 33% faster.
        if len(args) > len(opts.concrete_fields):
            # Daft, but matches old exception sans the err msg.
            raise IndexError("Number of args exceeds number of fields")
    
        if not kwargs:
            fields_iter = iter(opts.concrete_fields)
            # The ordering of the zip calls matter - zip throws StopIteration
            # when an iter throws it. So if the first iter throws it, the second
            # is *not* consumed. We rely on this, so don't change the order
            # without changing the logic.
            for val, field in zip(args, fields_iter):
                if val is _DEFERRED:
                    continue
                _setattr(self, field.attname, val)
        else:
            # Slower, kwargs-ready version.
            fields_iter = iter(opts.fields)
            for val, field in zip(args, fields_iter):
                if val is _DEFERRED:
                    continue
                _setattr(self, field.attname, val)
                if kwargs.pop(field.name, NOT_PROVIDED) is not NOT_PROVIDED:
                    raise TypeError(
                        f"{cls.__qualname__}() got both positional and "
                        f"keyword arguments for field '{field.name}'."
                    )
    
        # Now we're left with the unprocessed fields that *must* come from
        # keywords, or default.
    
        for field in fields_iter:
            is_related_object = False
            # Virtual field
            if field.attname not in kwargs and field.column is None:
                continue
            if kwargs:
                if isinstance(field.remote_field, ForeignObjectRel):
                    try:
                        # Assume object instance was passed in.
                        rel_obj = kwargs.pop(field.name)
                        is_related_object = True
                    except KeyError:
                        try:
                            # Object instance wasn't passed in -- must be an ID.
                            val = kwargs.pop(field.attname)
                        except KeyError:
                            val = field.get_default()
                else:
                    try:
                        val = kwargs.pop(field.attname)
                    except KeyError:
                        # This is done with an exception rather than the
                        # default argument on pop because we don't want
                        # get_default() to be evaluated, and then not used.
                        # Refs #12057.
                        val = field.get_default()
            else:
                val = field.get_default()
    
            if is_related_object:
                # If we are passed a related instance, set it using the
                # field.name instead of field.attname (e.g. "user" instead of
                # "user_id") so that the object gets properly cached (and type
                # checked) by the RelatedObjectDescriptor.
                if rel_obj is not _DEFERRED:
                    _setattr(self, field.name, rel_obj)
            else:
                if val is not _DEFERRED:
                    _setattr(self, field.attname, val)
    
        if kwargs:
            property_names = opts._property_names
            unexpected = ()
            for prop, value in kwargs.items():
                # Any remaining kwargs must correspond to properties or virtual
                # fields.
                if prop in property_names:
                    if value is not _DEFERRED:
                        _setattr(self, prop, value)
                else:
                    try:
                        opts.get_field(prop)
                    except FieldDoesNotExist:
                        unexpected += (prop,)
                    else:
                        if value is not _DEFERRED:
                            _setattr(self, prop, value)
            if unexpected:
                unexpected_names = ", ".join(repr(n) for n in unexpected)
>               raise TypeError(
                    f"{cls.__name__}() got unexpected keyword arguments: "
                    f"{unexpected_names}"
                )
E               TypeError: DocumentType() got unexpected keyword arguments: 'prefix'

/usr/local/lib/python3.11/site-packages/django/db/models/base.py:567: TypeError
_ ERROR at setup of TestSubmitForReview.test_non_author_cannot_submit_for_review _

self = <apps.workflows.tests.test_review_workflow.TestSubmitForReview object at 0x7e0a00425a90>

    def setup_method(self):
        """Setup test data"""
        self.client = APIClient()
    
        # Create users
        self.author = User.objects.create_user(
            username='test_author',
            password='test123',
            email='author@test.com'
        )
    
        self.reviewer = User.objects.create_user(
            username='test_reviewer',
            password='test123',
            email='reviewer@test.com'
        )
    
        # Assign reviewer role
        reviewer_role, _ = Role.objects.get_or_create(
            name='Document Reviewer',
            defaults={
                'module': 'S2',
                'permission_level': 'reviewer'
            }
        )
        UserRole.objects.create(
            user=self.reviewer,
            role=reviewer_role,
            is_active=True
        )
    
        # Create document type and source
>       self.doc_type = DocumentType.objects.create(
            code='TST',
            name='Test Document',
            prefix='TST'
        )

apps/workflows/tests/test_review_workflow.py:59: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.11/site-packages/django/db/models/manager.py:87: in manager_method
    return getattr(self.get_queryset(), name)(*args, **kwargs)
/usr/local/lib/python3.11/site-packages/django/db/models/query.py:656: in create
    obj = self.model(**kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <DocumentType: Test Document (TST)>, args = ()
kwargs = {'prefix': 'TST'}, cls = <class 'apps.documents.models.DocumentType'>
opts = <Options for DocumentType>, _setattr = <built-in function setattr>
_DEFERRED = <Deferred field>
fields_iter = <tuple_iterator object at 0x7e09ffd5dc30>, val = {}
field = <django.db.models.fields.json.JSONField: metadata>
is_related_object = False, property_names = frozenset({'pk'})

    def __init__(self, *args, **kwargs):
        # Alias some things as locals to avoid repeat global lookups
        cls = self.__class__
        opts = self._meta
        _setattr = setattr
        _DEFERRED = DEFERRED
        if opts.abstract:
            raise TypeError("Abstract models cannot be instantiated.")
    
        pre_init.send(sender=cls, args=args, kwargs=kwargs)
    
        # Set up the storage for instance state
        self._state = ModelState()
    
        # There is a rather weird disparity here; if kwargs, it's set, then args
        # overrides it. It should be one or the other; don't duplicate the work
        # The reason for the kwargs check is that standard iterator passes in by
        # args, and instantiation for iteration is 33% faster.
        if len(args) > len(opts.concrete_fields):
            # Daft, but matches old exception sans the err msg.
            raise IndexError("Number of args exceeds number of fields")
    
        if not kwargs:
            fields_iter = iter(opts.concrete_fields)
            # The ordering of the zip calls matter - zip throws StopIteration
            # when an iter throws it. So if the first iter throws it, the second
            # is *not* consumed. We rely on this, so don't change the order
            # without changing the logic.
            for val, field in zip(args, fields_iter):
                if val is _DEFERRED:
                    continue
                _setattr(self, field.attname, val)
        else:
            # Slower, kwargs-ready version.
            fields_iter = iter(opts.fields)
            for val, field in zip(args, fields_iter):
                if val is _DEFERRED:
                    continue
                _setattr(self, field.attname, val)
                if kwargs.pop(field.name, NOT_PROVIDED) is not NOT_PROVIDED:
                    raise TypeError(
                        f"{cls.__qualname__}() got both positional and "
                        f"keyword arguments for field '{field.name}'."
                    )
    
        # Now we're left with the unprocessed fields that *must* come from
        # keywords, or default.
    
        for field in fields_iter:
            is_related_object = False
            # Virtual field
            if field.attname not in kwargs and field.column is None:
                continue
            if kwargs:
                if isinstance(field.remote_field, ForeignObjectRel):
                    try:
                        # Assume object instance was passed in.
                        rel_obj = kwargs.pop(field.name)
                        is_related_object = True
                    except KeyError:
                        try:
                            # Object instance wasn't passed in -- must be an ID.
                            val = kwargs.pop(field.attname)
                        except KeyError:
                            val = field.get_default()
                else:
                    try:
                        val = kwargs.pop(field.attname)
                    except KeyError:
                        # This is done with an exception rather than the
                        # default argument on pop because we don't want
                        # get_default() to be evaluated, and then not used.
                        # Refs #12057.
                        val = field.get_default()
            else:
                val = field.get_default()
    
            if is_related_object:
                # If we are passed a related instance, set it using the
                # field.name instead of field.attname (e.g. "user" instead of
                # "user_id") so that the object gets properly cached (and type
                # checked) by the RelatedObjectDescriptor.
                if rel_obj is not _DEFERRED:
                    _setattr(self, field.name, rel_obj)
            else:
                if val is not _DEFERRED:
                    _setattr(self, field.attname, val)
    
        if kwargs:
            property_names = opts._property_names
            unexpected = ()
            for prop, value in kwargs.items():
                # Any remaining kwargs must correspond to properties or virtual
                # fields.
                if prop in property_names:
                    if value is not _DEFERRED:
                        _setattr(self, prop, value)
                else:
                    try:
                        opts.get_field(prop)
                    except FieldDoesNotExist:
                        unexpected += (prop,)
                    else:
                        if value is not _DEFERRED:
                            _setattr(self, prop, value)
            if unexpected:
                unexpected_names = ", ".join(repr(n) for n in unexpected)
>               raise TypeError(
                    f"{cls.__name__}() got unexpected keyword arguments: "
                    f"{unexpected_names}"
                )
E               TypeError: DocumentType() got unexpected keyword arguments: 'prefix'

/usr/local/lib/python3.11/site-packages/django/db/models/base.py:567: TypeError
_ ERROR at setup of TestSubmitForReview.test_cannot_submit_already_reviewed_document _

self = <apps.workflows.tests.test_review_workflow.TestSubmitForReview object at 0x7e0a004260d0>

    def setup_method(self):
        """Setup test data"""
        self.client = APIClient()
    
        # Create users
        self.author = User.objects.create_user(
            username='test_author',
            password='test123',
            email='author@test.com'
        )
    
        self.reviewer = User.objects.create_user(
            username='test_reviewer',
            password='test123',
            email='reviewer@test.com'
        )
    
        # Assign reviewer role
        reviewer_role, _ = Role.objects.get_or_create(
            name='Document Reviewer',
            defaults={
                'module': 'S2',
                'permission_level': 'reviewer'
            }
        )
        UserRole.objects.create(
            user=self.reviewer,
            role=reviewer_role,
            is_active=True
        )
    
        # Create document type and source
>       self.doc_type = DocumentType.objects.create(
            code='TST',
            name='Test Document',
            prefix='TST'
        )

apps/workflows/tests/test_review_workflow.py:59: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.11/site-packages/django/db/models/manager.py:87: in manager_method
    return getattr(self.get_queryset(), name)(*args, **kwargs)
/usr/local/lib/python3.11/site-packages/django/db/models/query.py:656: in create
    obj = self.model(**kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <DocumentType: Test Document (TST)>, args = ()
kwargs = {'prefix': 'TST'}, cls = <class 'apps.documents.models.DocumentType'>
opts = <Options for DocumentType>, _setattr = <built-in function setattr>
_DEFERRED = <Deferred field>
fields_iter = <tuple_iterator object at 0x7e09ffdf8b80>, val = {}
field = <django.db.models.fields.json.JSONField: metadata>
is_related_object = False, property_names = frozenset({'pk'})

    def __init__(self, *args, **kwargs):
        # Alias some things as locals to avoid repeat global lookups
        cls = self.__class__
        opts = self._meta
        _setattr = setattr
        _DEFERRED = DEFERRED
        if opts.abstract:
            raise TypeError("Abstract models cannot be instantiated.")
    
        pre_init.send(sender=cls, args=args, kwargs=kwargs)
    
        # Set up the storage for instance state
        self._state = ModelState()
    
        # There is a rather weird disparity here; if kwargs, it's set, then args
        # overrides it. It should be one or the other; don't duplicate the work
        # The reason for the kwargs check is that standard iterator passes in by
        # args, and instantiation for iteration is 33% faster.
        if len(args) > len(opts.concrete_fields):
            # Daft, but matches old exception sans the err msg.
            raise IndexError("Number of args exceeds number of fields")
    
        if not kwargs:
            fields_iter = iter(opts.concrete_fields)
            # The ordering of the zip calls matter - zip throws StopIteration
            # when an iter throws it. So if the first iter throws it, the second
            # is *not* consumed. We rely on this, so don't change the order
            # without changing the logic.
            for val, field in zip(args, fields_iter):
                if val is _DEFERRED:
                    continue
                _setattr(self, field.attname, val)
        else:
            # Slower, kwargs-ready version.
            fields_iter = iter(opts.fields)
            for val, field in zip(args, fields_iter):
                if val is _DEFERRED:
                    continue
                _setattr(self, field.attname, val)
                if kwargs.pop(field.name, NOT_PROVIDED) is not NOT_PROVIDED:
                    raise TypeError(
                        f"{cls.__qualname__}() got both positional and "
                        f"keyword arguments for field '{field.name}'."
                    )
    
        # Now we're left with the unprocessed fields that *must* come from
        # keywords, or default.
    
        for field in fields_iter:
            is_related_object = False
            # Virtual field
            if field.attname not in kwargs and field.column is None:
                continue
            if kwargs:
                if isinstance(field.remote_field, ForeignObjectRel):
                    try:
                        # Assume object instance was passed in.
                        rel_obj = kwargs.pop(field.name)
                        is_related_object = True
                    except KeyError:
                        try:
                            # Object instance wasn't passed in -- must be an ID.
                            val = kwargs.pop(field.attname)
                        except KeyError:
                            val = field.get_default()
                else:
                    try:
                        val = kwargs.pop(field.attname)
                    except KeyError:
                        # This is done with an exception rather than the
                        # default argument on pop because we don't want
                        # get_default() to be evaluated, and then not used.
                        # Refs #12057.
                        val = field.get_default()
            else:
                val = field.get_default()
    
            if is_related_object:
                # If we are passed a related instance, set it using the
                # field.name instead of field.attname (e.g. "user" instead of
                # "user_id") so that the object gets properly cached (and type
                # checked) by the RelatedObjectDescriptor.
                if rel_obj is not _DEFERRED:
                    _setattr(self, field.name, rel_obj)
            else:
                if val is not _DEFERRED:
                    _setattr(self, field.attname, val)
    
        if kwargs:
            property_names = opts._property_names
            unexpected = ()
            for prop, value in kwargs.items():
                # Any remaining kwargs must correspond to properties or virtual
                # fields.
                if prop in property_names:
                    if value is not _DEFERRED:
                        _setattr(self, prop, value)
                else:
                    try:
                        opts.get_field(prop)
                    except FieldDoesNotExist:
                        unexpected += (prop,)
                    else:
                        if value is not _DEFERRED:
                            _setattr(self, prop, value)
            if unexpected:
                unexpected_names = ", ".join(repr(n) for n in unexpected)
>               raise TypeError(
                    f"{cls.__name__}() got unexpected keyword arguments: "
                    f"{unexpected_names}"
                )
E               TypeError: DocumentType() got unexpected keyword arguments: 'prefix'

/usr/local/lib/python3.11/site-packages/django/db/models/base.py:567: TypeError
___ ERROR at setup of TestReviewerActions.test_reviewer_can_approve_document ___

self = <apps.workflows.tests.test_review_workflow.TestReviewerActions object at 0x7e0a00426310>

    def setup_method(self):
        """Setup test data with document under review"""
        self.client = APIClient()
    
        # Create users
        self.author = User.objects.create_user(
            username='test_author',
            password='test123'
        )
    
        self.reviewer = User.objects.create_user(
            username='test_reviewer',
            password='test123'
        )
    
        self.other_user = User.objects.create_user(
            username='other_user',
            password='test123'
        )
    
        # Assign reviewer role
        reviewer_role, _ = Role.objects.get_or_create(
            name='Document Reviewer',
            defaults={
                'module': 'S2',
                'permission_level': 'reviewer'
            }
        )
        UserRole.objects.create(
            user=self.reviewer,
            role=reviewer_role,
            is_active=True
        )
    
        # Create document type
>       self.doc_type = DocumentType.objects.create(
            code='TST',
            name='Test Document',
            prefix='TST'
        )

apps/workflows/tests/test_review_workflow.py:171: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.11/site-packages/django/db/models/manager.py:87: in manager_method
    return getattr(self.get_queryset(), name)(*args, **kwargs)
/usr/local/lib/python3.11/site-packages/django/db/models/query.py:656: in create
    obj = self.model(**kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <DocumentType: Test Document (TST)>, args = ()
kwargs = {'prefix': 'TST'}, cls = <class 'apps.documents.models.DocumentType'>
opts = <Options for DocumentType>, _setattr = <built-in function setattr>
_DEFERRED = <Deferred field>
fields_iter = <tuple_iterator object at 0x7e09ffdded70>, val = {}
field = <django.db.models.fields.json.JSONField: metadata>
is_related_object = False, property_names = frozenset({'pk'})

    def __init__(self, *args, **kwargs):
        # Alias some things as locals to avoid repeat global lookups
        cls = self.__class__
        opts = self._meta
        _setattr = setattr
        _DEFERRED = DEFERRED
        if opts.abstract:
            raise TypeError("Abstract models cannot be instantiated.")
    
        pre_init.send(sender=cls, args=args, kwargs=kwargs)
    
        # Set up the storage for instance state
        self._state = ModelState()
    
        # There is a rather weird disparity here; if kwargs, it's set, then args
        # overrides it. It should be one or the other; don't duplicate the work
        # The reason for the kwargs check is that standard iterator passes in by
        # args, and instantiation for iteration is 33% faster.
        if len(args) > len(opts.concrete_fields):
            # Daft, but matches old exception sans the err msg.
            raise IndexError("Number of args exceeds number of fields")
    
        if not kwargs:
            fields_iter = iter(opts.concrete_fields)
            # The ordering of the zip calls matter - zip throws StopIteration
            # when an iter throws it. So if the first iter throws it, the second
            # is *not* consumed. We rely on this, so don't change the order
            # without changing the logic.
            for val, field in zip(args, fields_iter):
                if val is _DEFERRED:
                    continue
                _setattr(self, field.attname, val)
        else:
            # Slower, kwargs-ready version.
            fields_iter = iter(opts.fields)
            for val, field in zip(args, fields_iter):
                if val is _DEFERRED:
                    continue
                _setattr(self, field.attname, val)
                if kwargs.pop(field.name, NOT_PROVIDED) is not NOT_PROVIDED:
                    raise TypeError(
                        f"{cls.__qualname__}() got both positional and "
                        f"keyword arguments for field '{field.name}'."
                    )
    
        # Now we're left with the unprocessed fields that *must* come from
        # keywords, or default.
    
        for field in fields_iter:
            is_related_object = False
            # Virtual field
            if field.attname not in kwargs and field.column is None:
                continue
            if kwargs:
                if isinstance(field.remote_field, ForeignObjectRel):
                    try:
                        # Assume object instance was passed in.
                        rel_obj = kwargs.pop(field.name)
                        is_related_object = True
                    except KeyError:
                        try:
                            # Object instance wasn't passed in -- must be an ID.
                            val = kwargs.pop(field.attname)
                        except KeyError:
                            val = field.get_default()
                else:
                    try:
                        val = kwargs.pop(field.attname)
                    except KeyError:
                        # This is done with an exception rather than the
                        # default argument on pop because we don't want
                        # get_default() to be evaluated, and then not used.
                        # Refs #12057.
                        val = field.get_default()
            else:
                val = field.get_default()
    
            if is_related_object:
                # If we are passed a related instance, set it using the
                # field.name instead of field.attname (e.g. "user" instead of
                # "user_id") so that the object gets properly cached (and type
                # checked) by the RelatedObjectDescriptor.
                if rel_obj is not _DEFERRED:
                    _setattr(self, field.name, rel_obj)
            else:
                if val is not _DEFERRED:
                    _setattr(self, field.attname, val)
    
        if kwargs:
            property_names = opts._property_names
            unexpected = ()
            for prop, value in kwargs.items():
                # Any remaining kwargs must correspond to properties or virtual
                # fields.
                if prop in property_names:
                    if value is not _DEFERRED:
                        _setattr(self, prop, value)
                else:
                    try:
                        opts.get_field(prop)
                    except FieldDoesNotExist:
                        unexpected += (prop,)
                    else:
                        if value is not _DEFERRED:
                            _setattr(self, prop, value)
            if unexpected:
                unexpected_names = ", ".join(repr(n) for n in unexpected)
>               raise TypeError(
                    f"{cls.__name__}() got unexpected keyword arguments: "
                    f"{unexpected_names}"
                )
E               TypeError: DocumentType() got unexpected keyword arguments: 'prefix'

/usr/local/lib/python3.11/site-packages/django/db/models/base.py:567: TypeError
___ ERROR at setup of TestReviewerActions.test_reviewer_can_reject_document ____

self = <apps.workflows.tests.test_review_workflow.TestReviewerActions object at 0x7e0a00425910>

    def setup_method(self):
        """Setup test data with document under review"""
        self.client = APIClient()
    
        # Create users
        self.author = User.objects.create_user(
            username='test_author',
            password='test123'
        )
    
        self.reviewer = User.objects.create_user(
            username='test_reviewer',
            password='test123'
        )
    
        self.other_user = User.objects.create_user(
            username='other_user',
            password='test123'
        )
    
        # Assign reviewer role
        reviewer_role, _ = Role.objects.get_or_create(
            name='Document Reviewer',
            defaults={
                'module': 'S2',
                'permission_level': 'reviewer'
            }
        )
        UserRole.objects.create(
            user=self.reviewer,
            role=reviewer_role,
            is_active=True
        )
    
        # Create document type
>       self.doc_type = DocumentType.objects.create(
            code='TST',
            name='Test Document',
            prefix='TST'
        )

apps/workflows/tests/test_review_workflow.py:171: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.11/site-packages/django/db/models/manager.py:87: in manager_method
    return getattr(self.get_queryset(), name)(*args, **kwargs)
/usr/local/lib/python3.11/site-packages/django/db/models/query.py:656: in create
    obj = self.model(**kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <DocumentType: Test Document (TST)>, args = ()
kwargs = {'prefix': 'TST'}, cls = <class 'apps.documents.models.DocumentType'>
opts = <Options for DocumentType>, _setattr = <built-in function setattr>
_DEFERRED = <Deferred field>
fields_iter = <tuple_iterator object at 0x7e09ffdca950>, val = {}
field = <django.db.models.fields.json.JSONField: metadata>
is_related_object = False, property_names = frozenset({'pk'})

    def __init__(self, *args, **kwargs):
        # Alias some things as locals to avoid repeat global lookups
        cls = self.__class__
        opts = self._meta
        _setattr = setattr
        _DEFERRED = DEFERRED
        if opts.abstract:
            raise TypeError("Abstract models cannot be instantiated.")
    
        pre_init.send(sender=cls, args=args, kwargs=kwargs)
    
        # Set up the storage for instance state
        self._state = ModelState()
    
        # There is a rather weird disparity here; if kwargs, it's set, then args
        # overrides it. It should be one or the other; don't duplicate the work
        # The reason for the kwargs check is that standard iterator passes in by
        # args, and instantiation for iteration is 33% faster.
        if len(args) > len(opts.concrete_fields):
            # Daft, but matches old exception sans the err msg.
            raise IndexError("Number of args exceeds number of fields")
    
        if not kwargs:
            fields_iter = iter(opts.concrete_fields)
            # The ordering of the zip calls matter - zip throws StopIteration
            # when an iter throws it. So if the first iter throws it, the second
            # is *not* consumed. We rely on this, so don't change the order
            # without changing the logic.
            for val, field in zip(args, fields_iter):
                if val is _DEFERRED:
                    continue
                _setattr(self, field.attname, val)
        else:
            # Slower, kwargs-ready version.
            fields_iter = iter(opts.fields)
            for val, field in zip(args, fields_iter):
                if val is _DEFERRED:
                    continue
                _setattr(self, field.attname, val)
                if kwargs.pop(field.name, NOT_PROVIDED) is not NOT_PROVIDED:
                    raise TypeError(
                        f"{cls.__qualname__}() got both positional and "
                        f"keyword arguments for field '{field.name}'."
                    )
    
        # Now we're left with the unprocessed fields that *must* come from
        # keywords, or default.
    
        for field in fields_iter:
            is_related_object = False
            # Virtual field
            if field.attname not in kwargs and field.column is None:
                continue
            if kwargs:
                if isinstance(field.remote_field, ForeignObjectRel):
                    try:
                        # Assume object instance was passed in.
                        rel_obj = kwargs.pop(field.name)
                        is_related_object = True
                    except KeyError:
                        try:
                            # Object instance wasn't passed in -- must be an ID.
                            val = kwargs.pop(field.attname)
                        except KeyError:
                            val = field.get_default()
                else:
                    try:
                        val = kwargs.pop(field.attname)
                    except KeyError:
                        # This is done with an exception rather than the
                        # default argument on pop because we don't want
                        # get_default() to be evaluated, and then not used.
                        # Refs #12057.
                        val = field.get_default()
            else:
                val = field.get_default()
    
            if is_related_object:
                # If we are passed a related instance, set it using the
                # field.name instead of field.attname (e.g. "user" instead of
                # "user_id") so that the object gets properly cached (and type
                # checked) by the RelatedObjectDescriptor.
                if rel_obj is not _DEFERRED:
                    _setattr(self, field.name, rel_obj)
            else:
                if val is not _DEFERRED:
                    _setattr(self, field.attname, val)
    
        if kwargs:
            property_names = opts._property_names
            unexpected = ()
            for prop, value in kwargs.items():
                # Any remaining kwargs must correspond to properties or virtual
                # fields.
                if prop in property_names:
                    if value is not _DEFERRED:
                        _setattr(self, prop, value)
                else:
                    try:
                        opts.get_field(prop)
                    except FieldDoesNotExist:
                        unexpected += (prop,)
                    else:
                        if value is not _DEFERRED:
                            _setattr(self, prop, value)
            if unexpected:
                unexpected_names = ", ".join(repr(n) for n in unexpected)
>               raise TypeError(
                    f"{cls.__name__}() got unexpected keyword arguments: "
                    f"{unexpected_names}"
                )
E               TypeError: DocumentType() got unexpected keyword arguments: 'prefix'

/usr/local/lib/python3.11/site-packages/django/db/models/base.py:567: TypeError
_ ERROR at setup of TestReviewerActions.test_non_reviewer_cannot_approve_document _

self = <apps.workflows.tests.test_review_workflow.TestReviewerActions object at 0x7e0a00427f50>

    def setup_method(self):
        """Setup test data with document under review"""
        self.client = APIClient()
    
        # Create users
        self.author = User.objects.create_user(
            username='test_author',
            password='test123'
        )
    
        self.reviewer = User.objects.create_user(
            username='test_reviewer',
            password='test123'
        )
    
        self.other_user = User.objects.create_user(
            username='other_user',
            password='test123'
        )
    
        # Assign reviewer role
        reviewer_role, _ = Role.objects.get_or_create(
            name='Document Reviewer',
            defaults={
                'module': 'S2',
                'permission_level': 'reviewer'
            }
        )
        UserRole.objects.create(
            user=self.reviewer,
            role=reviewer_role,
            is_active=True
        )
    
        # Create document type
>       self.doc_type = DocumentType.objects.create(
            code='TST',
            name='Test Document',
            prefix='TST'
        )

apps/workflows/tests/test_review_workflow.py:171: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.11/site-packages/django/db/models/manager.py:87: in manager_method
    return getattr(self.get_queryset(), name)(*args, **kwargs)
/usr/local/lib/python3.11/site-packages/django/db/models/query.py:656: in create
    obj = self.model(**kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <DocumentType: Test Document (TST)>, args = ()
kwargs = {'prefix': 'TST'}, cls = <class 'apps.documents.models.DocumentType'>
opts = <Options for DocumentType>, _setattr = <built-in function setattr>
_DEFERRED = <Deferred field>
fields_iter = <tuple_iterator object at 0x7e09ff6980a0>, val = {}
field = <django.db.models.fields.json.JSONField: metadata>
is_related_object = False, property_names = frozenset({'pk'})

    def __init__(self, *args, **kwargs):
        # Alias some things as locals to avoid repeat global lookups
        cls = self.__class__
        opts = self._meta
        _setattr = setattr
        _DEFERRED = DEFERRED
        if opts.abstract:
            raise TypeError("Abstract models cannot be instantiated.")
    
        pre_init.send(sender=cls, args=args, kwargs=kwargs)
    
        # Set up the storage for instance state
        self._state = ModelState()
    
        # There is a rather weird disparity here; if kwargs, it's set, then args
        # overrides it. It should be one or the other; don't duplicate the work
        # The reason for the kwargs check is that standard iterator passes in by
        # args, and instantiation for iteration is 33% faster.
        if len(args) > len(opts.concrete_fields):
            # Daft, but matches old exception sans the err msg.
            raise IndexError("Number of args exceeds number of fields")
    
        if not kwargs:
            fields_iter = iter(opts.concrete_fields)
            # The ordering of the zip calls matter - zip throws StopIteration
            # when an iter throws it. So if the first iter throws it, the second
            # is *not* consumed. We rely on this, so don't change the order
            # without changing the logic.
            for val, field in zip(args, fields_iter):
                if val is _DEFERRED:
                    continue
                _setattr(self, field.attname, val)
        else:
            # Slower, kwargs-ready version.
            fields_iter = iter(opts.fields)
            for val, field in zip(args, fields_iter):
                if val is _DEFERRED:
                    continue
                _setattr(self, field.attname, val)
                if kwargs.pop(field.name, NOT_PROVIDED) is not NOT_PROVIDED:
                    raise TypeError(
                        f"{cls.__qualname__}() got both positional and "
                        f"keyword arguments for field '{field.name}'."
                    )
    
        # Now we're left with the unprocessed fields that *must* come from
        # keywords, or default.
    
        for field in fields_iter:
            is_related_object = False
            # Virtual field
            if field.attname not in kwargs and field.column is None:
                continue
            if kwargs:
                if isinstance(field.remote_field, ForeignObjectRel):
                    try:
                        # Assume object instance was passed in.
                        rel_obj = kwargs.pop(field.name)
                        is_related_object = True
                    except KeyError:
                        try:
                            # Object instance wasn't passed in -- must be an ID.
                            val = kwargs.pop(field.attname)
                        except KeyError:
                            val = field.get_default()
                else:
                    try:
                        val = kwargs.pop(field.attname)
                    except KeyError:
                        # This is done with an exception rather than the
                        # default argument on pop because we don't want
                        # get_default() to be evaluated, and then not used.
                        # Refs #12057.
                        val = field.get_default()
            else:
                val = field.get_default()
    
            if is_related_object:
                # If we are passed a related instance, set it using the
                # field.name instead of field.attname (e.g. "user" instead of
                # "user_id") so that the object gets properly cached (and type
                # checked) by the RelatedObjectDescriptor.
                if rel_obj is not _DEFERRED:
                    _setattr(self, field.name, rel_obj)
            else:
                if val is not _DEFERRED:
                    _setattr(self, field.attname, val)
    
        if kwargs:
            property_names = opts._property_names
            unexpected = ()
            for prop, value in kwargs.items():
                # Any remaining kwargs must correspond to properties or virtual
                # fields.
                if prop in property_names:
                    if value is not _DEFERRED:
                        _setattr(self, prop, value)
                else:
                    try:
                        opts.get_field(prop)
                    except FieldDoesNotExist:
                        unexpected += (prop,)
                    else:
                        if value is not _DEFERRED:
                            _setattr(self, prop, value)
            if unexpected:
                unexpected_names = ", ".join(repr(n) for n in unexpected)
>               raise TypeError(
                    f"{cls.__name__}() got unexpected keyword arguments: "
                    f"{unexpected_names}"
                )
E               TypeError: DocumentType() got unexpected keyword arguments: 'prefix'

/usr/local/lib/python3.11/site-packages/django/db/models/base.py:567: TypeError
_ ERROR at setup of TestReviewerActions.test_author_cannot_review_own_document _

self = <apps.workflows.tests.test_review_workflow.TestReviewerActions object at 0x7e0a00427b10>

    def setup_method(self):
        """Setup test data with document under review"""
        self.client = APIClient()
    
        # Create users
        self.author = User.objects.create_user(
            username='test_author',
            password='test123'
        )
    
        self.reviewer = User.objects.create_user(
            username='test_reviewer',
            password='test123'
        )
    
        self.other_user = User.objects.create_user(
            username='other_user',
            password='test123'
        )
    
        # Assign reviewer role
        reviewer_role, _ = Role.objects.get_or_create(
            name='Document Reviewer',
            defaults={
                'module': 'S2',
                'permission_level': 'reviewer'
            }
        )
        UserRole.objects.create(
            user=self.reviewer,
            role=reviewer_role,
            is_active=True
        )
    
        # Create document type
>       self.doc_type = DocumentType.objects.create(
            code='TST',
            name='Test Document',
            prefix='TST'
        )

apps/workflows/tests/test_review_workflow.py:171: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.11/site-packages/django/db/models/manager.py:87: in manager_method
    return getattr(self.get_queryset(), name)(*args, **kwargs)
/usr/local/lib/python3.11/site-packages/django/db/models/query.py:656: in create
    obj = self.model(**kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <DocumentType: Test Document (TST)>, args = ()
kwargs = {'prefix': 'TST'}, cls = <class 'apps.documents.models.DocumentType'>
opts = <Options for DocumentType>, _setattr = <built-in function setattr>
_DEFERRED = <Deferred field>
fields_iter = <tuple_iterator object at 0x7e09ffb215a0>, val = {}
field = <django.db.models.fields.json.JSONField: metadata>
is_related_object = False, property_names = frozenset({'pk'})

    def __init__(self, *args, **kwargs):
        # Alias some things as locals to avoid repeat global lookups
        cls = self.__class__
        opts = self._meta
        _setattr = setattr
        _DEFERRED = DEFERRED
        if opts.abstract:
            raise TypeError("Abstract models cannot be instantiated.")
    
        pre_init.send(sender=cls, args=args, kwargs=kwargs)
    
        # Set up the storage for instance state
        self._state = ModelState()
    
        # There is a rather weird disparity here; if kwargs, it's set, then args
        # overrides it. It should be one or the other; don't duplicate the work
        # The reason for the kwargs check is that standard iterator passes in by
        # args, and instantiation for iteration is 33% faster.
        if len(args) > len(opts.concrete_fields):
            # Daft, but matches old exception sans the err msg.
            raise IndexError("Number of args exceeds number of fields")
    
        if not kwargs:
            fields_iter = iter(opts.concrete_fields)
            # The ordering of the zip calls matter - zip throws StopIteration
            # when an iter throws it. So if the first iter throws it, the second
            # is *not* consumed. We rely on this, so don't change the order
            # without changing the logic.
            for val, field in zip(args, fields_iter):
                if val is _DEFERRED:
                    continue
                _setattr(self, field.attname, val)
        else:
            # Slower, kwargs-ready version.
            fields_iter = iter(opts.fields)
            for val, field in zip(args, fields_iter):
                if val is _DEFERRED:
                    continue
                _setattr(self, field.attname, val)
                if kwargs.pop(field.name, NOT_PROVIDED) is not NOT_PROVIDED:
                    raise TypeError(
                        f"{cls.__qualname__}() got both positional and "
                        f"keyword arguments for field '{field.name}'."
                    )
    
        # Now we're left with the unprocessed fields that *must* come from
        # keywords, or default.
    
        for field in fields_iter:
            is_related_object = False
            # Virtual field
            if field.attname not in kwargs and field.column is None:
                continue
            if kwargs:
                if isinstance(field.remote_field, ForeignObjectRel):
                    try:
                        # Assume object instance was passed in.
                        rel_obj = kwargs.pop(field.name)
                        is_related_object = True
                    except KeyError:
                        try:
                            # Object instance wasn't passed in -- must be an ID.
                            val = kwargs.pop(field.attname)
                        except KeyError:
                            val = field.get_default()
                else:
                    try:
                        val = kwargs.pop(field.attname)
                    except KeyError:
                        # This is done with an exception rather than the
                        # default argument on pop because we don't want
                        # get_default() to be evaluated, and then not used.
                        # Refs #12057.
                        val = field.get_default()
            else:
                val = field.get_default()
    
            if is_related_object:
                # If we are passed a related instance, set it using the
                # field.name instead of field.attname (e.g. "user" instead of
                # "user_id") so that the object gets properly cached (and type
                # checked) by the RelatedObjectDescriptor.
                if rel_obj is not _DEFERRED:
                    _setattr(self, field.name, rel_obj)
            else:
                if val is not _DEFERRED:
                    _setattr(self, field.attname, val)
    
        if kwargs:
            property_names = opts._property_names
            unexpected = ()
            for prop, value in kwargs.items():
                # Any remaining kwargs must correspond to properties or virtual
                # fields.
                if prop in property_names:
                    if value is not _DEFERRED:
                        _setattr(self, prop, value)
                else:
                    try:
                        opts.get_field(prop)
                    except FieldDoesNotExist:
                        unexpected += (prop,)
                    else:
                        if value is not _DEFERRED:
                            _setattr(self, prop, value)
            if unexpected:
                unexpected_names = ", ".join(repr(n) for n in unexpected)
>               raise TypeError(
                    f"{cls.__name__}() got unexpected keyword arguments: "
                    f"{unexpected_names}"
                )
E               TypeError: DocumentType() got unexpected keyword arguments: 'prefix'

/usr/local/lib/python3.11/site-packages/django/db/models/base.py:567: TypeError
______ ERROR at setup of TestReviewerActions.test_review_requires_comment ______

self = <apps.workflows.tests.test_review_workflow.TestReviewerActions object at 0x7e0a004242d0>

    def setup_method(self):
        """Setup test data with document under review"""
        self.client = APIClient()
    
        # Create users
        self.author = User.objects.create_user(
            username='test_author',
            password='test123'
        )
    
        self.reviewer = User.objects.create_user(
            username='test_reviewer',
            password='test123'
        )
    
        self.other_user = User.objects.create_user(
            username='other_user',
            password='test123'
        )
    
        # Assign reviewer role
        reviewer_role, _ = Role.objects.get_or_create(
            name='Document Reviewer',
            defaults={
                'module': 'S2',
                'permission_level': 'reviewer'
            }
        )
        UserRole.objects.create(
            user=self.reviewer,
            role=reviewer_role,
            is_active=True
        )
    
        # Create document type
>       self.doc_type = DocumentType.objects.create(
            code='TST',
            name='Test Document',
            prefix='TST'
        )

apps/workflows/tests/test_review_workflow.py:171: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.11/site-packages/django/db/models/manager.py:87: in manager_method
    return getattr(self.get_queryset(), name)(*args, **kwargs)
/usr/local/lib/python3.11/site-packages/django/db/models/query.py:656: in create
    obj = self.model(**kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <DocumentType: Test Document (TST)>, args = ()
kwargs = {'prefix': 'TST'}, cls = <class 'apps.documents.models.DocumentType'>
opts = <Options for DocumentType>, _setattr = <built-in function setattr>
_DEFERRED = <Deferred field>
fields_iter = <tuple_iterator object at 0x7e09ff664e80>, val = {}
field = <django.db.models.fields.json.JSONField: metadata>
is_related_object = False, property_names = frozenset({'pk'})

    def __init__(self, *args, **kwargs):
        # Alias some things as locals to avoid repeat global lookups
        cls = self.__class__
        opts = self._meta
        _setattr = setattr
        _DEFERRED = DEFERRED
        if opts.abstract:
            raise TypeError("Abstract models cannot be instantiated.")
    
        pre_init.send(sender=cls, args=args, kwargs=kwargs)
    
        # Set up the storage for instance state
        self._state = ModelState()
    
        # There is a rather weird disparity here; if kwargs, it's set, then args
        # overrides it. It should be one or the other; don't duplicate the work
        # The reason for the kwargs check is that standard iterator passes in by
        # args, and instantiation for iteration is 33% faster.
        if len(args) > len(opts.concrete_fields):
            # Daft, but matches old exception sans the err msg.
            raise IndexError("Number of args exceeds number of fields")
    
        if not kwargs:
            fields_iter = iter(opts.concrete_fields)
            # The ordering of the zip calls matter - zip throws StopIteration
            # when an iter throws it. So if the first iter throws it, the second
            # is *not* consumed. We rely on this, so don't change the order
            # without changing the logic.
            for val, field in zip(args, fields_iter):
                if val is _DEFERRED:
                    continue
                _setattr(self, field.attname, val)
        else:
            # Slower, kwargs-ready version.
            fields_iter = iter(opts.fields)
            for val, field in zip(args, fields_iter):
                if val is _DEFERRED:
                    continue
                _setattr(self, field.attname, val)
                if kwargs.pop(field.name, NOT_PROVIDED) is not NOT_PROVIDED:
                    raise TypeError(
                        f"{cls.__qualname__}() got both positional and "
                        f"keyword arguments for field '{field.name}'."
                    )
    
        # Now we're left with the unprocessed fields that *must* come from
        # keywords, or default.
    
        for field in fields_iter:
            is_related_object = False
            # Virtual field
            if field.attname not in kwargs and field.column is None:
                continue
            if kwargs:
                if isinstance(field.remote_field, ForeignObjectRel):
                    try:
                        # Assume object instance was passed in.
                        rel_obj = kwargs.pop(field.name)
                        is_related_object = True
                    except KeyError:
                        try:
                            # Object instance wasn't passed in -- must be an ID.
                            val = kwargs.pop(field.attname)
                        except KeyError:
                            val = field.get_default()
                else:
                    try:
                        val = kwargs.pop(field.attname)
                    except KeyError:
                        # This is done with an exception rather than the
                        # default argument on pop because we don't want
                        # get_default() to be evaluated, and then not used.
                        # Refs #12057.
                        val = field.get_default()
            else:
                val = field.get_default()
    
            if is_related_object:
                # If we are passed a related instance, set it using the
                # field.name instead of field.attname (e.g. "user" instead of
                # "user_id") so that the object gets properly cached (and type
                # checked) by the RelatedObjectDescriptor.
                if rel_obj is not _DEFERRED:
                    _setattr(self, field.name, rel_obj)
            else:
                if val is not _DEFERRED:
                    _setattr(self, field.attname, val)
    
        if kwargs:
            property_names = opts._property_names
            unexpected = ()
            for prop, value in kwargs.items():
                # Any remaining kwargs must correspond to properties or virtual
                # fields.
                if prop in property_names:
                    if value is not _DEFERRED:
                        _setattr(self, prop, value)
                else:
                    try:
                        opts.get_field(prop)
                    except FieldDoesNotExist:
                        unexpected += (prop,)
                    else:
                        if value is not _DEFERRED:
                            _setattr(self, prop, value)
            if unexpected:
                unexpected_names = ", ".join(repr(n) for n in unexpected)
>               raise TypeError(
                    f"{cls.__name__}() got unexpected keyword arguments: "
                    f"{unexpected_names}"
                )
E               TypeError: DocumentType() got unexpected keyword arguments: 'prefix'

/usr/local/lib/python3.11/site-packages/django/db/models/base.py:567: TypeError
___ ERROR at setup of TestReviewerActions.test_cannot_review_draft_document ____

self = <apps.workflows.tests.test_review_workflow.TestReviewerActions object at 0x7e0a004244d0>

    def setup_method(self):
        """Setup test data with document under review"""
        self.client = APIClient()
    
        # Create users
        self.author = User.objects.create_user(
            username='test_author',
            password='test123'
        )
    
        self.reviewer = User.objects.create_user(
            username='test_reviewer',
            password='test123'
        )
    
        self.other_user = User.objects.create_user(
            username='other_user',
            password='test123'
        )
    
        # Assign reviewer role
        reviewer_role, _ = Role.objects.get_or_create(
            name='Document Reviewer',
            defaults={
                'module': 'S2',
                'permission_level': 'reviewer'
            }
        )
        UserRole.objects.create(
            user=self.reviewer,
            role=reviewer_role,
            is_active=True
        )
    
        # Create document type
>       self.doc_type = DocumentType.objects.create(
            code='TST',
            name='Test Document',
            prefix='TST'
        )

apps/workflows/tests/test_review_workflow.py:171: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.11/site-packages/django/db/models/manager.py:87: in manager_method
    return getattr(self.get_queryset(), name)(*args, **kwargs)
/usr/local/lib/python3.11/site-packages/django/db/models/query.py:656: in create
    obj = self.model(**kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <DocumentType: Test Document (TST)>, args = ()
kwargs = {'prefix': 'TST'}, cls = <class 'apps.documents.models.DocumentType'>
opts = <Options for DocumentType>, _setattr = <built-in function setattr>
_DEFERRED = <Deferred field>
fields_iter = <tuple_iterator object at 0x7e09ffb4fcd0>, val = {}
field = <django.db.models.fields.json.JSONField: metadata>
is_related_object = False, property_names = frozenset({'pk'})

    def __init__(self, *args, **kwargs):
        # Alias some things as locals to avoid repeat global lookups
        cls = self.__class__
        opts = self._meta
        _setattr = setattr
        _DEFERRED = DEFERRED
        if opts.abstract:
            raise TypeError("Abstract models cannot be instantiated.")
    
        pre_init.send(sender=cls, args=args, kwargs=kwargs)
    
        # Set up the storage for instance state
        self._state = ModelState()
    
        # There is a rather weird disparity here; if kwargs, it's set, then args
        # overrides it. It should be one or the other; don't duplicate the work
        # The reason for the kwargs check is that standard iterator passes in by
        # args, and instantiation for iteration is 33% faster.
        if len(args) > len(opts.concrete_fields):
            # Daft, but matches old exception sans the err msg.
            raise IndexError("Number of args exceeds number of fields")
    
        if not kwargs:
            fields_iter = iter(opts.concrete_fields)
            # The ordering of the zip calls matter - zip throws StopIteration
            # when an iter throws it. So if the first iter throws it, the second
            # is *not* consumed. We rely on this, so don't change the order
            # without changing the logic.
            for val, field in zip(args, fields_iter):
                if val is _DEFERRED:
                    continue
                _setattr(self, field.attname, val)
        else:
            # Slower, kwargs-ready version.
            fields_iter = iter(opts.fields)
            for val, field in zip(args, fields_iter):
                if val is _DEFERRED:
                    continue
                _setattr(self, field.attname, val)
                if kwargs.pop(field.name, NOT_PROVIDED) is not NOT_PROVIDED:
                    raise TypeError(
                        f"{cls.__qualname__}() got both positional and "
                        f"keyword arguments for field '{field.name}'."
                    )
    
        # Now we're left with the unprocessed fields that *must* come from
        # keywords, or default.
    
        for field in fields_iter:
            is_related_object = False
            # Virtual field
            if field.attname not in kwargs and field.column is None:
                continue
            if kwargs:
                if isinstance(field.remote_field, ForeignObjectRel):
                    try:
                        # Assume object instance was passed in.
                        rel_obj = kwargs.pop(field.name)
                        is_related_object = True
                    except KeyError:
                        try:
                            # Object instance wasn't passed in -- must be an ID.
                            val = kwargs.pop(field.attname)
                        except KeyError:
                            val = field.get_default()
                else:
                    try:
                        val = kwargs.pop(field.attname)
                    except KeyError:
                        # This is done with an exception rather than the
                        # default argument on pop because we don't want
                        # get_default() to be evaluated, and then not used.
                        # Refs #12057.
                        val = field.get_default()
            else:
                val = field.get_default()
    
            if is_related_object:
                # If we are passed a related instance, set it using the
                # field.name instead of field.attname (e.g. "user" instead of
                # "user_id") so that the object gets properly cached (and type
                # checked) by the RelatedObjectDescriptor.
                if rel_obj is not _DEFERRED:
                    _setattr(self, field.name, rel_obj)
            else:
                if val is not _DEFERRED:
                    _setattr(self, field.attname, val)
    
        if kwargs:
            property_names = opts._property_names
            unexpected = ()
            for prop, value in kwargs.items():
                # Any remaining kwargs must correspond to properties or virtual
                # fields.
                if prop in property_names:
                    if value is not _DEFERRED:
                        _setattr(self, prop, value)
                else:
                    try:
                        opts.get_field(prop)
                    except FieldDoesNotExist:
                        unexpected += (prop,)
                    else:
                        if value is not _DEFERRED:
                            _setattr(self, prop, value)
            if unexpected:
                unexpected_names = ", ".join(repr(n) for n in unexpected)
>               raise TypeError(
                    f"{cls.__name__}() got unexpected keyword arguments: "
                    f"{unexpected_names}"
                )
E               TypeError: DocumentType() got unexpected keyword arguments: 'prefix'

/usr/local/lib/python3.11/site-packages/django/db/models/base.py:567: TypeError
_ ERROR at setup of TestDocumentTermination.test_author_can_terminate_draft_document _

self = <apps.workflows.tests.test_termination_workflow.TestDocumentTermination object at 0x7e0a00422210>

    def setup_method(self):
        """Setup test data"""
        self.author = User.objects.create_user(
            username='author_term',
            password='test123'
        )
        self.other_user = User.objects.create_user(
            username='other_term',
            password='test123'
        )
    
        # Create WorkflowType objects (REQUIRED for lifecycle service)
        self.review_workflow_type = WorkflowType.objects.create(
            name='Document Review',
            workflow_type='REVIEW',
            created_by=self.author
        )
        self.approval_workflow_type = WorkflowType.objects.create(
            name='Document Approval',
            workflow_type='APPROVAL',
            created_by=self.author
        )
    
        # Create DocumentState objects (REQUIRED for workflow transitions)
        for code, name in [
            ('DRAFT', 'Draft'),
            ('UNDER_REVIEW', 'Under Review'),
            ('REVIEW_COMPLETED', 'Review Completed'),
            ('PENDING_APPROVAL', 'Pending Approval'),
            ('APPROVED_PENDING_EFFECTIVE', 'Approved Pending Effective'),
            ('EFFECTIVE', 'Effective'),
            ('TERMINATED', 'Terminated'),
        ]:
>           DocumentState.objects.create(
                name=name,
                code=code
            )
E           NameError: name 'DocumentState' is not defined

apps/workflows/tests/test_termination_workflow.py:62: NameError
_ ERROR at setup of TestDocumentTermination.test_author_can_terminate_under_review_document _

self = <apps.workflows.tests.test_termination_workflow.TestDocumentTermination object at 0x7e0a00433ad0>

    def setup_method(self):
        """Setup test data"""
        self.author = User.objects.create_user(
            username='author_term',
            password='test123'
        )
        self.other_user = User.objects.create_user(
            username='other_term',
            password='test123'
        )
    
        # Create WorkflowType objects (REQUIRED for lifecycle service)
        self.review_workflow_type = WorkflowType.objects.create(
            name='Document Review',
            workflow_type='REVIEW',
            created_by=self.author
        )
        self.approval_workflow_type = WorkflowType.objects.create(
            name='Document Approval',
            workflow_type='APPROVAL',
            created_by=self.author
        )
    
        # Create DocumentState objects (REQUIRED for workflow transitions)
        for code, name in [
            ('DRAFT', 'Draft'),
            ('UNDER_REVIEW', 'Under Review'),
            ('REVIEW_COMPLETED', 'Review Completed'),
            ('PENDING_APPROVAL', 'Pending Approval'),
            ('APPROVED_PENDING_EFFECTIVE', 'Approved Pending Effective'),
            ('EFFECTIVE', 'Effective'),
            ('TERMINATED', 'Terminated'),
        ]:
>           DocumentState.objects.create(
                name=name,
                code=code
            )
E           NameError: name 'DocumentState' is not defined

apps/workflows/tests/test_termination_workflow.py:62: NameError
_ ERROR at setup of TestDocumentTermination.test_author_can_terminate_pending_approval_document _

self = <apps.workflows.tests.test_termination_workflow.TestDocumentTermination object at 0x7e0a00431410>

    def setup_method(self):
        """Setup test data"""
        self.author = User.objects.create_user(
            username='author_term',
            password='test123'
        )
        self.other_user = User.objects.create_user(
            username='other_term',
            password='test123'
        )
    
        # Create WorkflowType objects (REQUIRED for lifecycle service)
        self.review_workflow_type = WorkflowType.objects.create(
            name='Document Review',
            workflow_type='REVIEW',
            created_by=self.author
        )
        self.approval_workflow_type = WorkflowType.objects.create(
            name='Document Approval',
            workflow_type='APPROVAL',
            created_by=self.author
        )
    
        # Create DocumentState objects (REQUIRED for workflow transitions)
        for code, name in [
            ('DRAFT', 'Draft'),
            ('UNDER_REVIEW', 'Under Review'),
            ('REVIEW_COMPLETED', 'Review Completed'),
            ('PENDING_APPROVAL', 'Pending Approval'),
            ('APPROVED_PENDING_EFFECTIVE', 'Approved Pending Effective'),
            ('EFFECTIVE', 'Effective'),
            ('TERMINATED', 'Terminated'),
        ]:
>           DocumentState.objects.create(
                name=name,
                code=code
            )
E           NameError: name 'DocumentState' is not defined

apps/workflows/tests/test_termination_workflow.py:62: NameError
__ ERROR at setup of TestDocumentTermination.test_termination_requires_reason __

self = <apps.workflows.tests.test_termination_workflow.TestDocumentTermination object at 0x7e0a004330d0>

    def setup_method(self):
        """Setup test data"""
        self.author = User.objects.create_user(
            username='author_term',
            password='test123'
        )
        self.other_user = User.objects.create_user(
            username='other_term',
            password='test123'
        )
    
        # Create WorkflowType objects (REQUIRED for lifecycle service)
        self.review_workflow_type = WorkflowType.objects.create(
            name='Document Review',
            workflow_type='REVIEW',
            created_by=self.author
        )
        self.approval_workflow_type = WorkflowType.objects.create(
            name='Document Approval',
            workflow_type='APPROVAL',
            created_by=self.author
        )
    
        # Create DocumentState objects (REQUIRED for workflow transitions)
        for code, name in [
            ('DRAFT', 'Draft'),
            ('UNDER_REVIEW', 'Under Review'),
            ('REVIEW_COMPLETED', 'Review Completed'),
            ('PENDING_APPROVAL', 'Pending Approval'),
            ('APPROVED_PENDING_EFFECTIVE', 'Approved Pending Effective'),
            ('EFFECTIVE', 'Effective'),
            ('TERMINATED', 'Terminated'),
        ]:
>           DocumentState.objects.create(
                name=name,
                code=code
            )
E           NameError: name 'DocumentState' is not defined

apps/workflows/tests/test_termination_workflow.py:62: NameError
_ ERROR at setup of TestDocumentTermination.test_cannot_terminate_effective_document _

self = <apps.workflows.tests.test_termination_workflow.TestDocumentTermination object at 0x7e0a00431590>

    def setup_method(self):
        """Setup test data"""
        self.author = User.objects.create_user(
            username='author_term',
            password='test123'
        )
        self.other_user = User.objects.create_user(
            username='other_term',
            password='test123'
        )
    
        # Create WorkflowType objects (REQUIRED for lifecycle service)
        self.review_workflow_type = WorkflowType.objects.create(
            name='Document Review',
            workflow_type='REVIEW',
            created_by=self.author
        )
        self.approval_workflow_type = WorkflowType.objects.create(
            name='Document Approval',
            workflow_type='APPROVAL',
            created_by=self.author
        )
    
        # Create DocumentState objects (REQUIRED for workflow transitions)
        for code, name in [
            ('DRAFT', 'Draft'),
            ('UNDER_REVIEW', 'Under Review'),
            ('REVIEW_COMPLETED', 'Review Completed'),
            ('PENDING_APPROVAL', 'Pending Approval'),
            ('APPROVED_PENDING_EFFECTIVE', 'Approved Pending Effective'),
            ('EFFECTIVE', 'Effective'),
            ('TERMINATED', 'Terminated'),
        ]:
>           DocumentState.objects.create(
                name=name,
                code=code
            )
E           NameError: name 'DocumentState' is not defined

apps/workflows/tests/test_termination_workflow.py:62: NameError
__ ERROR at setup of TestDocumentTermination.test_non_author_cannot_terminate __

self = <apps.workflows.tests.test_termination_workflow.TestDocumentTermination object at 0x7e0a00430410>

    def setup_method(self):
        """Setup test data"""
        self.author = User.objects.create_user(
            username='author_term',
            password='test123'
        )
        self.other_user = User.objects.create_user(
            username='other_term',
            password='test123'
        )
    
        # Create WorkflowType objects (REQUIRED for lifecycle service)
        self.review_workflow_type = WorkflowType.objects.create(
            name='Document Review',
            workflow_type='REVIEW',
            created_by=self.author
        )
        self.approval_workflow_type = WorkflowType.objects.create(
            name='Document Approval',
            workflow_type='APPROVAL',
            created_by=self.author
        )
    
        # Create DocumentState objects (REQUIRED for workflow transitions)
        for code, name in [
            ('DRAFT', 'Draft'),
            ('UNDER_REVIEW', 'Under Review'),
            ('REVIEW_COMPLETED', 'Review Completed'),
            ('PENDING_APPROVAL', 'Pending Approval'),
            ('APPROVED_PENDING_EFFECTIVE', 'Approved Pending Effective'),
            ('EFFECTIVE', 'Effective'),
            ('TERMINATED', 'Terminated'),
        ]:
>           DocumentState.objects.create(
                name=name,
                code=code
            )
E           NameError: name 'DocumentState' is not defined

apps/workflows/tests/test_termination_workflow.py:62: NameError
_ ERROR at setup of TestDocumentTermination.test_terminated_documents_are_read_only _

self = <apps.workflows.tests.test_termination_workflow.TestDocumentTermination object at 0x7e0a00430710>

    def setup_method(self):
        """Setup test data"""
        self.author = User.objects.create_user(
            username='author_term',
            password='test123'
        )
        self.other_user = User.objects.create_user(
            username='other_term',
            password='test123'
        )
    
        # Create WorkflowType objects (REQUIRED for lifecycle service)
        self.review_workflow_type = WorkflowType.objects.create(
            name='Document Review',
            workflow_type='REVIEW',
            created_by=self.author
        )
        self.approval_workflow_type = WorkflowType.objects.create(
            name='Document Approval',
            workflow_type='APPROVAL',
            created_by=self.author
        )
    
        # Create DocumentState objects (REQUIRED for workflow transitions)
        for code, name in [
            ('DRAFT', 'Draft'),
            ('UNDER_REVIEW', 'Under Review'),
            ('REVIEW_COMPLETED', 'Review Completed'),
            ('PENDING_APPROVAL', 'Pending Approval'),
            ('APPROVED_PENDING_EFFECTIVE', 'Approved Pending Effective'),
            ('EFFECTIVE', 'Effective'),
            ('TERMINATED', 'Terminated'),
        ]:
>           DocumentState.objects.create(
                name=name,
                code=code
            )
E           NameError: name 'DocumentState' is not defined

apps/workflows/tests/test_termination_workflow.py:62: NameError
_ ERROR at teardown of TestWorkflowNotifications.test_notification_created_on_submit_for_review _

self = <django.db.backends.utils.CursorWrapper object at 0x7e09ff908b10>
sql = 'SET CONSTRAINTS ALL IMMEDIATE', params = None
ignored_wrapper_args = (False, {'connection': <DatabaseWrapper vendor='postgresql' alias='default'>, 'cursor': <django.db.backends.utils.CursorWrapper object at 0x7e09ff908b10>})

    def _execute(self, sql, params, *ignored_wrapper_args):
        self.db.validate_no_broken_transaction()
        with self.db.wrap_database_errors:
            if params is None:
                # params default might be backend specific.
>               return self.cursor.execute(sql)
E               psycopg2.errors.ForeignKeyViolation: insert or update on table "document_workflows" violates foreign key constraint "document_workflows_current_state_id_a6868f25_fk_workflow_"
E               DETAIL:  Key (current_state_id)=(DRAFT) is not present in table "workflow_document_states".

/usr/local/lib/python3.11/site-packages/django/db/backends/utils.py:87: ForeignKeyViolation

The above exception was the direct cause of the following exception:

request = <SubRequest '_django_db_helper' for <Function test_notification_created_on_submit_for_review>>
django_db_setup = None
django_db_blocker = <pytest_django.plugin.DjangoDbBlocker object at 0x7e0a03be5110>

    @pytest.fixture()
    def _django_db_helper(
        request: pytest.FixtureRequest,
        django_db_setup: None,
        django_db_blocker: DjangoDbBlocker,
    ) -> Generator[None, None, None]:
        from django import VERSION
    
        if is_django_unittest(request):
            yield
            return
    
        marker = request.node.get_closest_marker("django_db")
        if marker:
            (
                transactional,
                reset_sequences,
                databases,
                serialized_rollback,
                available_apps,
            ) = validate_django_db(marker)
        else:
            (
                transactional,
                reset_sequences,
                databases,
                serialized_rollback,
                available_apps,
            ) = False, False, None, False, None
    
        transactional = (
            transactional
            or reset_sequences
            or ("transactional_db" in request.fixturenames or "live_server" in request.fixturenames)
        )
        reset_sequences = reset_sequences or ("django_db_reset_sequences" in request.fixturenames)
        serialized_rollback = serialized_rollback or (
            "django_db_serialized_rollback" in request.fixturenames
        )
    
        django_db_blocker.unblock()
    
        import django.db
        import django.test
    
        if transactional:
            test_case_class = django.test.TransactionTestCase
        else:
            test_case_class = django.test.TestCase
    
        _reset_sequences = reset_sequences
        _serialized_rollback = serialized_rollback
        _databases = databases
        _available_apps = available_apps
    
        class PytestDjangoTestCase(test_case_class):  # type: ignore[misc,valid-type]
            reset_sequences = _reset_sequences
            serialized_rollback = _serialized_rollback
            if _databases is not None:
                databases = _databases
            if _available_apps is not None:
                available_apps = _available_apps
    
            # For non-transactional tests, skip executing `django.test.TestCase`'s
            # `setUpClass`/`tearDownClass`, only execute the super class ones.
            #
            # `TestCase`'s class setup manages the `setUpTestData`/class-level
            # transaction functionality. We don't use it; instead we (will) offer
            # our own alternatives. So it only adds overhead, and does some things
            # which conflict with our (planned) functionality, particularly, it
            # closes all database connections in `tearDownClass` which inhibits
            # wrapping tests in higher-scoped transactions.
            #
            # It's possible a new version of Django will add some unrelated
            # functionality to these methods, in which case skipping them completely
            # would not be desirable. Let's cross that bridge when we get there...
            if not transactional:
    
                @classmethod
                def setUpClass(cls) -> None:
                    super(django.test.TestCase, cls).setUpClass()
                    if VERSION < (4, 1):
                        django.db.transaction.Atomic._ensure_durability = False
    
                @classmethod
                def tearDownClass(cls) -> None:
                    if VERSION < (4, 1):
                        django.db.transaction.Atomic._ensure_durability = True
                    super(django.test.TestCase, cls).tearDownClass()
    
        PytestDjangoTestCase.setUpClass()
    
        test_case = PytestDjangoTestCase(methodName="__init__")
        test_case._pre_setup()
    
        yield
    
>       test_case._post_teardown()

/home/edms/.local/lib/python3.11/site-packages/pytest_django/fixtures.py:255: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.11/site-packages/django/test/testcases.py:1279: in _post_teardown
    self._fixture_teardown()
/usr/local/lib/python3.11/site-packages/django/test/testcases.py:1509: in _fixture_teardown
    connections[db_name].check_constraints()
/usr/local/lib/python3.11/site-packages/django/db/backends/postgresql/base.py:383: in check_constraints
    cursor.execute("SET CONSTRAINTS ALL IMMEDIATE")
/usr/local/lib/python3.11/site-packages/django/db/backends/utils.py:67: in execute
    return self._execute_with_wrappers(
/usr/local/lib/python3.11/site-packages/django/db/backends/utils.py:80: in _execute_with_wrappers
    return executor(sql, params, many, context)
/usr/local/lib/python3.11/site-packages/django/db/backends/utils.py:84: in _execute
    with self.db.wrap_database_errors:
/usr/local/lib/python3.11/site-packages/django/db/utils.py:91: in __exit__
    raise dj_exc_value.with_traceback(traceback) from exc_value
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.db.backends.utils.CursorWrapper object at 0x7e09ff908b10>
sql = 'SET CONSTRAINTS ALL IMMEDIATE', params = None
ignored_wrapper_args = (False, {'connection': <DatabaseWrapper vendor='postgresql' alias='default'>, 'cursor': <django.db.backends.utils.CursorWrapper object at 0x7e09ff908b10>})

    def _execute(self, sql, params, *ignored_wrapper_args):
        self.db.validate_no_broken_transaction()
        with self.db.wrap_database_errors:
            if params is None:
                # params default might be backend specific.
>               return self.cursor.execute(sql)
E               django.db.utils.IntegrityError: insert or update on table "document_workflows" violates foreign key constraint "document_workflows_current_state_id_a6868f25_fk_workflow_"
E               DETAIL:  Key (current_state_id)=(DRAFT) is not present in table "workflow_document_states".

/usr/local/lib/python3.11/site-packages/django/db/backends/utils.py:87: IntegrityError
----------------------------- Captured stdout call -----------------------------
 submit_for_review called for RPT-2026-0001-v01.00
   Document status: DRAFT
   User: notif_author
   Reviewer assigned: notif_reviewer
 No active workflow found, creating new workflow...
 Workflow created: RPT-2026-0001-v01.00 - REVIEW
    Workflow created: ID 12, state: DRAFT
 Transitioning workflow from DRAFT to PENDING_REVIEW...
Workflow transition failed: 'PENDING_REVIEW'
 Transition result: False
 Transition failed
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "/app/apps/workflows/document_lifecycle.py", line 1254, in _transition_workflow
    to_state = self.states[to_state_code]
               ~~~~~~~~~~~^^^^^^^^^^^^^^^
KeyError: 'PENDING_REVIEW'
___ ERROR at setup of TestReviewRejections.test_reject_with_detailed_comment ___

self = <apps.workflows.tests.test_workflow_rejections.TestReviewRejections object at 0x7e0a00308290>

    def setup_method(self):
        """Setup test data"""
        self.client = APIClient()
    
        # Create users
        self.author = User.objects.create_user(
            username='test_author',
            password='test123'
        )
    
        self.reviewer = User.objects.create_user(
            username='test_reviewer',
            password='test123'
        )
    
        # Assign reviewer role
        reviewer_role, _ = Role.objects.get_or_create(
            name='Document Reviewer',
            defaults={'module': 'S2', 'permission_level': 'reviewer'}
        )
        UserRole.objects.create(user=self.reviewer, role=reviewer_role, is_active=True)
    
        # Create document type
>       self.doc_type = DocumentType.objects.create(
            code='TST', name='Test Document', prefix='TST'
        )

apps/workflows/tests/test_workflow_rejections.py:51: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.11/site-packages/django/db/models/manager.py:87: in manager_method
    return getattr(self.get_queryset(), name)(*args, **kwargs)
/usr/local/lib/python3.11/site-packages/django/db/models/query.py:656: in create
    obj = self.model(**kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <DocumentType: Test Document (TST)>, args = ()
kwargs = {'prefix': 'TST'}, cls = <class 'apps.documents.models.DocumentType'>
opts = <Options for DocumentType>, _setattr = <built-in function setattr>
_DEFERRED = <Deferred field>
fields_iter = <tuple_iterator object at 0x7e09ffd8fe20>, val = {}
field = <django.db.models.fields.json.JSONField: metadata>
is_related_object = False, property_names = frozenset({'pk'})

    def __init__(self, *args, **kwargs):
        # Alias some things as locals to avoid repeat global lookups
        cls = self.__class__
        opts = self._meta
        _setattr = setattr
        _DEFERRED = DEFERRED
        if opts.abstract:
            raise TypeError("Abstract models cannot be instantiated.")
    
        pre_init.send(sender=cls, args=args, kwargs=kwargs)
    
        # Set up the storage for instance state
        self._state = ModelState()
    
        # There is a rather weird disparity here; if kwargs, it's set, then args
        # overrides it. It should be one or the other; don't duplicate the work
        # The reason for the kwargs check is that standard iterator passes in by
        # args, and instantiation for iteration is 33% faster.
        if len(args) > len(opts.concrete_fields):
            # Daft, but matches old exception sans the err msg.
            raise IndexError("Number of args exceeds number of fields")
    
        if not kwargs:
            fields_iter = iter(opts.concrete_fields)
            # The ordering of the zip calls matter - zip throws StopIteration
            # when an iter throws it. So if the first iter throws it, the second
            # is *not* consumed. We rely on this, so don't change the order
            # without changing the logic.
            for val, field in zip(args, fields_iter):
                if val is _DEFERRED:
                    continue
                _setattr(self, field.attname, val)
        else:
            # Slower, kwargs-ready version.
            fields_iter = iter(opts.fields)
            for val, field in zip(args, fields_iter):
                if val is _DEFERRED:
                    continue
                _setattr(self, field.attname, val)
                if kwargs.pop(field.name, NOT_PROVIDED) is not NOT_PROVIDED:
                    raise TypeError(
                        f"{cls.__qualname__}() got both positional and "
                        f"keyword arguments for field '{field.name}'."
                    )
    
        # Now we're left with the unprocessed fields that *must* come from
        # keywords, or default.
    
        for field in fields_iter:
            is_related_object = False
            # Virtual field
            if field.attname not in kwargs and field.column is None:
                continue
            if kwargs:
                if isinstance(field.remote_field, ForeignObjectRel):
                    try:
                        # Assume object instance was passed in.
                        rel_obj = kwargs.pop(field.name)
                        is_related_object = True
                    except KeyError:
                        try:
                            # Object instance wasn't passed in -- must be an ID.
                            val = kwargs.pop(field.attname)
                        except KeyError:
                            val = field.get_default()
                else:
                    try:
                        val = kwargs.pop(field.attname)
                    except KeyError:
                        # This is done with an exception rather than the
                        # default argument on pop because we don't want
                        # get_default() to be evaluated, and then not used.
                        # Refs #12057.
                        val = field.get_default()
            else:
                val = field.get_default()
    
            if is_related_object:
                # If we are passed a related instance, set it using the
                # field.name instead of field.attname (e.g. "user" instead of
                # "user_id") so that the object gets properly cached (and type
                # checked) by the RelatedObjectDescriptor.
                if rel_obj is not _DEFERRED:
                    _setattr(self, field.name, rel_obj)
            else:
                if val is not _DEFERRED:
                    _setattr(self, field.attname, val)
    
        if kwargs:
            property_names = opts._property_names
            unexpected = ()
            for prop, value in kwargs.items():
                # Any remaining kwargs must correspond to properties or virtual
                # fields.
                if prop in property_names:
                    if value is not _DEFERRED:
                        _setattr(self, prop, value)
                else:
                    try:
                        opts.get_field(prop)
                    except FieldDoesNotExist:
                        unexpected += (prop,)
                    else:
                        if value is not _DEFERRED:
                            _setattr(self, prop, value)
            if unexpected:
                unexpected_names = ", ".join(repr(n) for n in unexpected)
>               raise TypeError(
                    f"{cls.__name__}() got unexpected keyword arguments: "
                    f"{unexpected_names}"
                )
E               TypeError: DocumentType() got unexpected keyword arguments: 'prefix'

/usr/local/lib/python3.11/site-packages/django/db/models/base.py:567: TypeError
_ ERROR at setup of TestReviewRejections.test_reject_without_comment_should_fail _

self = <apps.workflows.tests.test_workflow_rejections.TestReviewRejections object at 0x7e0a00309850>

    def setup_method(self):
        """Setup test data"""
        self.client = APIClient()
    
        # Create users
        self.author = User.objects.create_user(
            username='test_author',
            password='test123'
        )
    
        self.reviewer = User.objects.create_user(
            username='test_reviewer',
            password='test123'
        )
    
        # Assign reviewer role
        reviewer_role, _ = Role.objects.get_or_create(
            name='Document Reviewer',
            defaults={'module': 'S2', 'permission_level': 'reviewer'}
        )
        UserRole.objects.create(user=self.reviewer, role=reviewer_role, is_active=True)
    
        # Create document type
>       self.doc_type = DocumentType.objects.create(
            code='TST', name='Test Document', prefix='TST'
        )

apps/workflows/tests/test_workflow_rejections.py:51: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.11/site-packages/django/db/models/manager.py:87: in manager_method
    return getattr(self.get_queryset(), name)(*args, **kwargs)
/usr/local/lib/python3.11/site-packages/django/db/models/query.py:656: in create
    obj = self.model(**kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <DocumentType: Test Document (TST)>, args = ()
kwargs = {'prefix': 'TST'}, cls = <class 'apps.documents.models.DocumentType'>
opts = <Options for DocumentType>, _setattr = <built-in function setattr>
_DEFERRED = <Deferred field>
fields_iter = <tuple_iterator object at 0x7e09ffb10ac0>, val = {}
field = <django.db.models.fields.json.JSONField: metadata>
is_related_object = False, property_names = frozenset({'pk'})

    def __init__(self, *args, **kwargs):
        # Alias some things as locals to avoid repeat global lookups
        cls = self.__class__
        opts = self._meta
        _setattr = setattr
        _DEFERRED = DEFERRED
        if opts.abstract:
            raise TypeError("Abstract models cannot be instantiated.")
    
        pre_init.send(sender=cls, args=args, kwargs=kwargs)
    
        # Set up the storage for instance state
        self._state = ModelState()
    
        # There is a rather weird disparity here; if kwargs, it's set, then args
        # overrides it. It should be one or the other; don't duplicate the work
        # The reason for the kwargs check is that standard iterator passes in by
        # args, and instantiation for iteration is 33% faster.
        if len(args) > len(opts.concrete_fields):
            # Daft, but matches old exception sans the err msg.
            raise IndexError("Number of args exceeds number of fields")
    
        if not kwargs:
            fields_iter = iter(opts.concrete_fields)
            # The ordering of the zip calls matter - zip throws StopIteration
            # when an iter throws it. So if the first iter throws it, the second
            # is *not* consumed. We rely on this, so don't change the order
            # without changing the logic.
            for val, field in zip(args, fields_iter):
                if val is _DEFERRED:
                    continue
                _setattr(self, field.attname, val)
        else:
            # Slower, kwargs-ready version.
            fields_iter = iter(opts.fields)
            for val, field in zip(args, fields_iter):
                if val is _DEFERRED:
                    continue
                _setattr(self, field.attname, val)
                if kwargs.pop(field.name, NOT_PROVIDED) is not NOT_PROVIDED:
                    raise TypeError(
                        f"{cls.__qualname__}() got both positional and "
                        f"keyword arguments for field '{field.name}'."
                    )
    
        # Now we're left with the unprocessed fields that *must* come from
        # keywords, or default.
    
        for field in fields_iter:
            is_related_object = False
            # Virtual field
            if field.attname not in kwargs and field.column is None:
                continue
            if kwargs:
                if isinstance(field.remote_field, ForeignObjectRel):
                    try:
                        # Assume object instance was passed in.
                        rel_obj = kwargs.pop(field.name)
                        is_related_object = True
                    except KeyError:
                        try:
                            # Object instance wasn't passed in -- must be an ID.
                            val = kwargs.pop(field.attname)
                        except KeyError:
                            val = field.get_default()
                else:
                    try:
                        val = kwargs.pop(field.attname)
                    except KeyError:
                        # This is done with an exception rather than the
                        # default argument on pop because we don't want
                        # get_default() to be evaluated, and then not used.
                        # Refs #12057.
                        val = field.get_default()
            else:
                val = field.get_default()
    
            if is_related_object:
                # If we are passed a related instance, set it using the
                # field.name instead of field.attname (e.g. "user" instead of
                # "user_id") so that the object gets properly cached (and type
                # checked) by the RelatedObjectDescriptor.
                if rel_obj is not _DEFERRED:
                    _setattr(self, field.name, rel_obj)
            else:
                if val is not _DEFERRED:
                    _setattr(self, field.attname, val)
    
        if kwargs:
            property_names = opts._property_names
            unexpected = ()
            for prop, value in kwargs.items():
                # Any remaining kwargs must correspond to properties or virtual
                # fields.
                if prop in property_names:
                    if value is not _DEFERRED:
                        _setattr(self, prop, value)
                else:
                    try:
                        opts.get_field(prop)
                    except FieldDoesNotExist:
                        unexpected += (prop,)
                    else:
                        if value is not _DEFERRED:
                            _setattr(self, prop, value)
            if unexpected:
                unexpected_names = ", ".join(repr(n) for n in unexpected)
>               raise TypeError(
                    f"{cls.__name__}() got unexpected keyword arguments: "
                    f"{unexpected_names}"
                )
E               TypeError: DocumentType() got unexpected keyword arguments: 'prefix'

/usr/local/lib/python3.11/site-packages/django/db/models/base.py:567: TypeError
__ ERROR at setup of TestReviewRejections.test_rejection_creates_audit_trail ___

self = <apps.workflows.tests.test_workflow_rejections.TestReviewRejections object at 0x7e0a00308f90>

    def setup_method(self):
        """Setup test data"""
        self.client = APIClient()
    
        # Create users
        self.author = User.objects.create_user(
            username='test_author',
            password='test123'
        )
    
        self.reviewer = User.objects.create_user(
            username='test_reviewer',
            password='test123'
        )
    
        # Assign reviewer role
        reviewer_role, _ = Role.objects.get_or_create(
            name='Document Reviewer',
            defaults={'module': 'S2', 'permission_level': 'reviewer'}
        )
        UserRole.objects.create(user=self.reviewer, role=reviewer_role, is_active=True)
    
        # Create document type
>       self.doc_type = DocumentType.objects.create(
            code='TST', name='Test Document', prefix='TST'
        )

apps/workflows/tests/test_workflow_rejections.py:51: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.11/site-packages/django/db/models/manager.py:87: in manager_method
    return getattr(self.get_queryset(), name)(*args, **kwargs)
/usr/local/lib/python3.11/site-packages/django/db/models/query.py:656: in create
    obj = self.model(**kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <DocumentType: Test Document (TST)>, args = ()
kwargs = {'prefix': 'TST'}, cls = <class 'apps.documents.models.DocumentType'>
opts = <Options for DocumentType>, _setattr = <built-in function setattr>
_DEFERRED = <Deferred field>
fields_iter = <tuple_iterator object at 0x7e09ff994a90>, val = {}
field = <django.db.models.fields.json.JSONField: metadata>
is_related_object = False, property_names = frozenset({'pk'})

    def __init__(self, *args, **kwargs):
        # Alias some things as locals to avoid repeat global lookups
        cls = self.__class__
        opts = self._meta
        _setattr = setattr
        _DEFERRED = DEFERRED
        if opts.abstract:
            raise TypeError("Abstract models cannot be instantiated.")
    
        pre_init.send(sender=cls, args=args, kwargs=kwargs)
    
        # Set up the storage for instance state
        self._state = ModelState()
    
        # There is a rather weird disparity here; if kwargs, it's set, then args
        # overrides it. It should be one or the other; don't duplicate the work
        # The reason for the kwargs check is that standard iterator passes in by
        # args, and instantiation for iteration is 33% faster.
        if len(args) > len(opts.concrete_fields):
            # Daft, but matches old exception sans the err msg.
            raise IndexError("Number of args exceeds number of fields")
    
        if not kwargs:
            fields_iter = iter(opts.concrete_fields)
            # The ordering of the zip calls matter - zip throws StopIteration
            # when an iter throws it. So if the first iter throws it, the second
            # is *not* consumed. We rely on this, so don't change the order
            # without changing the logic.
            for val, field in zip(args, fields_iter):
                if val is _DEFERRED:
                    continue
                _setattr(self, field.attname, val)
        else:
            # Slower, kwargs-ready version.
            fields_iter = iter(opts.fields)
            for val, field in zip(args, fields_iter):
                if val is _DEFERRED:
                    continue
                _setattr(self, field.attname, val)
                if kwargs.pop(field.name, NOT_PROVIDED) is not NOT_PROVIDED:
                    raise TypeError(
                        f"{cls.__qualname__}() got both positional and "
                        f"keyword arguments for field '{field.name}'."
                    )
    
        # Now we're left with the unprocessed fields that *must* come from
        # keywords, or default.
    
        for field in fields_iter:
            is_related_object = False
            # Virtual field
            if field.attname not in kwargs and field.column is None:
                continue
            if kwargs:
                if isinstance(field.remote_field, ForeignObjectRel):
                    try:
                        # Assume object instance was passed in.
                        rel_obj = kwargs.pop(field.name)
                        is_related_object = True
                    except KeyError:
                        try:
                            # Object instance wasn't passed in -- must be an ID.
                            val = kwargs.pop(field.attname)
                        except KeyError:
                            val = field.get_default()
                else:
                    try:
                        val = kwargs.pop(field.attname)
                    except KeyError:
                        # This is done with an exception rather than the
                        # default argument on pop because we don't want
                        # get_default() to be evaluated, and then not used.
                        # Refs #12057.
                        val = field.get_default()
            else:
                val = field.get_default()
    
            if is_related_object:
                # If we are passed a related instance, set it using the
                # field.name instead of field.attname (e.g. "user" instead of
                # "user_id") so that the object gets properly cached (and type
                # checked) by the RelatedObjectDescriptor.
                if rel_obj is not _DEFERRED:
                    _setattr(self, field.name, rel_obj)
            else:
                if val is not _DEFERRED:
                    _setattr(self, field.attname, val)
    
        if kwargs:
            property_names = opts._property_names
            unexpected = ()
            for prop, value in kwargs.items():
                # Any remaining kwargs must correspond to properties or virtual
                # fields.
                if prop in property_names:
                    if value is not _DEFERRED:
                        _setattr(self, prop, value)
                else:
                    try:
                        opts.get_field(prop)
                    except FieldDoesNotExist:
                        unexpected += (prop,)
                    else:
                        if value is not _DEFERRED:
                            _setattr(self, prop, value)
            if unexpected:
                unexpected_names = ", ".join(repr(n) for n in unexpected)
>               raise TypeError(
                    f"{cls.__name__}() got unexpected keyword arguments: "
                    f"{unexpected_names}"
                )
E               TypeError: DocumentType() got unexpected keyword arguments: 'prefix'

/usr/local/lib/python3.11/site-packages/django/db/models/base.py:567: TypeError
___ ERROR at setup of TestReviewRejections.test_author_notified_of_rejection ___

self = <apps.workflows.tests.test_workflow_rejections.TestReviewRejections object at 0x7e0a00309b50>

    def setup_method(self):
        """Setup test data"""
        self.client = APIClient()
    
        # Create users
        self.author = User.objects.create_user(
            username='test_author',
            password='test123'
        )
    
        self.reviewer = User.objects.create_user(
            username='test_reviewer',
            password='test123'
        )
    
        # Assign reviewer role
        reviewer_role, _ = Role.objects.get_or_create(
            name='Document Reviewer',
            defaults={'module': 'S2', 'permission_level': 'reviewer'}
        )
        UserRole.objects.create(user=self.reviewer, role=reviewer_role, is_active=True)
    
        # Create document type
>       self.doc_type = DocumentType.objects.create(
            code='TST', name='Test Document', prefix='TST'
        )

apps/workflows/tests/test_workflow_rejections.py:51: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.11/site-packages/django/db/models/manager.py:87: in manager_method
    return getattr(self.get_queryset(), name)(*args, **kwargs)
/usr/local/lib/python3.11/site-packages/django/db/models/query.py:656: in create
    obj = self.model(**kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <DocumentType: Test Document (TST)>, args = ()
kwargs = {'prefix': 'TST'}, cls = <class 'apps.documents.models.DocumentType'>
opts = <Options for DocumentType>, _setattr = <built-in function setattr>
_DEFERRED = <Deferred field>
fields_iter = <tuple_iterator object at 0x7e09ff729090>, val = {}
field = <django.db.models.fields.json.JSONField: metadata>
is_related_object = False, property_names = frozenset({'pk'})

    def __init__(self, *args, **kwargs):
        # Alias some things as locals to avoid repeat global lookups
        cls = self.__class__
        opts = self._meta
        _setattr = setattr
        _DEFERRED = DEFERRED
        if opts.abstract:
            raise TypeError("Abstract models cannot be instantiated.")
    
        pre_init.send(sender=cls, args=args, kwargs=kwargs)
    
        # Set up the storage for instance state
        self._state = ModelState()
    
        # There is a rather weird disparity here; if kwargs, it's set, then args
        # overrides it. It should be one or the other; don't duplicate the work
        # The reason for the kwargs check is that standard iterator passes in by
        # args, and instantiation for iteration is 33% faster.
        if len(args) > len(opts.concrete_fields):
            # Daft, but matches old exception sans the err msg.
            raise IndexError("Number of args exceeds number of fields")
    
        if not kwargs:
            fields_iter = iter(opts.concrete_fields)
            # The ordering of the zip calls matter - zip throws StopIteration
            # when an iter throws it. So if the first iter throws it, the second
            # is *not* consumed. We rely on this, so don't change the order
            # without changing the logic.
            for val, field in zip(args, fields_iter):
                if val is _DEFERRED:
                    continue
                _setattr(self, field.attname, val)
        else:
            # Slower, kwargs-ready version.
            fields_iter = iter(opts.fields)
            for val, field in zip(args, fields_iter):
                if val is _DEFERRED:
                    continue
                _setattr(self, field.attname, val)
                if kwargs.pop(field.name, NOT_PROVIDED) is not NOT_PROVIDED:
                    raise TypeError(
                        f"{cls.__qualname__}() got both positional and "
                        f"keyword arguments for field '{field.name}'."
                    )
    
        # Now we're left with the unprocessed fields that *must* come from
        # keywords, or default.
    
        for field in fields_iter:
            is_related_object = False
            # Virtual field
            if field.attname not in kwargs and field.column is None:
                continue
            if kwargs:
                if isinstance(field.remote_field, ForeignObjectRel):
                    try:
                        # Assume object instance was passed in.
                        rel_obj = kwargs.pop(field.name)
                        is_related_object = True
                    except KeyError:
                        try:
                            # Object instance wasn't passed in -- must be an ID.
                            val = kwargs.pop(field.attname)
                        except KeyError:
                            val = field.get_default()
                else:
                    try:
                        val = kwargs.pop(field.attname)
                    except KeyError:
                        # This is done with an exception rather than the
                        # default argument on pop because we don't want
                        # get_default() to be evaluated, and then not used.
                        # Refs #12057.
                        val = field.get_default()
            else:
                val = field.get_default()
    
            if is_related_object:
                # If we are passed a related instance, set it using the
                # field.name instead of field.attname (e.g. "user" instead of
                # "user_id") so that the object gets properly cached (and type
                # checked) by the RelatedObjectDescriptor.
                if rel_obj is not _DEFERRED:
                    _setattr(self, field.name, rel_obj)
            else:
                if val is not _DEFERRED:
                    _setattr(self, field.attname, val)
    
        if kwargs:
            property_names = opts._property_names
            unexpected = ()
            for prop, value in kwargs.items():
                # Any remaining kwargs must correspond to properties or virtual
                # fields.
                if prop in property_names:
                    if value is not _DEFERRED:
                        _setattr(self, prop, value)
                else:
                    try:
                        opts.get_field(prop)
                    except FieldDoesNotExist:
                        unexpected += (prop,)
                    else:
                        if value is not _DEFERRED:
                            _setattr(self, prop, value)
            if unexpected:
                unexpected_names = ", ".join(repr(n) for n in unexpected)
>               raise TypeError(
                    f"{cls.__name__}() got unexpected keyword arguments: "
                    f"{unexpected_names}"
                )
E               TypeError: DocumentType() got unexpected keyword arguments: 'prefix'

/usr/local/lib/python3.11/site-packages/django/db/models/base.py:567: TypeError
__ ERROR at setup of TestApprovalRejections.test_approver_reject_with_reason ___

self = <apps.workflows.tests.test_workflow_rejections.TestApprovalRejections object at 0x7e0a00308fd0>

    def setup_method(self):
        """Setup test data"""
        self.client = APIClient()
    
        # Create users
        self.author = User.objects.create_user(
            username='test_author',
            password='test123'
        )
    
        self.approver = User.objects.create_user(
            username='test_approver',
            password='test123'
        )
    
        # Assign approver role
        approver_role, _ = Role.objects.get_or_create(
            name='Document Approver',
            defaults={'module': 'S2', 'permission_level': 'approver'}
        )
        UserRole.objects.create(user=self.approver, role=approver_role, is_active=True)
    
        # Create document type
>       self.doc_type = DocumentType.objects.create(
            code='TST', name='Test Document', prefix='TST'
        )

apps/workflows/tests/test_workflow_rejections.py:183: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.11/site-packages/django/db/models/manager.py:87: in manager_method
    return getattr(self.get_queryset(), name)(*args, **kwargs)
/usr/local/lib/python3.11/site-packages/django/db/models/query.py:656: in create
    obj = self.model(**kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <DocumentType: Test Document (TST)>, args = ()
kwargs = {'prefix': 'TST'}, cls = <class 'apps.documents.models.DocumentType'>
opts = <Options for DocumentType>, _setattr = <built-in function setattr>
_DEFERRED = <Deferred field>
fields_iter = <tuple_iterator object at 0x7e09ffb438e0>, val = {}
field = <django.db.models.fields.json.JSONField: metadata>
is_related_object = False, property_names = frozenset({'pk'})

    def __init__(self, *args, **kwargs):
        # Alias some things as locals to avoid repeat global lookups
        cls = self.__class__
        opts = self._meta
        _setattr = setattr
        _DEFERRED = DEFERRED
        if opts.abstract:
            raise TypeError("Abstract models cannot be instantiated.")
    
        pre_init.send(sender=cls, args=args, kwargs=kwargs)
    
        # Set up the storage for instance state
        self._state = ModelState()
    
        # There is a rather weird disparity here; if kwargs, it's set, then args
        # overrides it. It should be one or the other; don't duplicate the work
        # The reason for the kwargs check is that standard iterator passes in by
        # args, and instantiation for iteration is 33% faster.
        if len(args) > len(opts.concrete_fields):
            # Daft, but matches old exception sans the err msg.
            raise IndexError("Number of args exceeds number of fields")
    
        if not kwargs:
            fields_iter = iter(opts.concrete_fields)
            # The ordering of the zip calls matter - zip throws StopIteration
            # when an iter throws it. So if the first iter throws it, the second
            # is *not* consumed. We rely on this, so don't change the order
            # without changing the logic.
            for val, field in zip(args, fields_iter):
                if val is _DEFERRED:
                    continue
                _setattr(self, field.attname, val)
        else:
            # Slower, kwargs-ready version.
            fields_iter = iter(opts.fields)
            for val, field in zip(args, fields_iter):
                if val is _DEFERRED:
                    continue
                _setattr(self, field.attname, val)
                if kwargs.pop(field.name, NOT_PROVIDED) is not NOT_PROVIDED:
                    raise TypeError(
                        f"{cls.__qualname__}() got both positional and "
                        f"keyword arguments for field '{field.name}'."
                    )
    
        # Now we're left with the unprocessed fields that *must* come from
        # keywords, or default.
    
        for field in fields_iter:
            is_related_object = False
            # Virtual field
            if field.attname not in kwargs and field.column is None:
                continue
            if kwargs:
                if isinstance(field.remote_field, ForeignObjectRel):
                    try:
                        # Assume object instance was passed in.
                        rel_obj = kwargs.pop(field.name)
                        is_related_object = True
                    except KeyError:
                        try:
                            # Object instance wasn't passed in -- must be an ID.
                            val = kwargs.pop(field.attname)
                        except KeyError:
                            val = field.get_default()
                else:
                    try:
                        val = kwargs.pop(field.attname)
                    except KeyError:
                        # This is done with an exception rather than the
                        # default argument on pop because we don't want
                        # get_default() to be evaluated, and then not used.
                        # Refs #12057.
                        val = field.get_default()
            else:
                val = field.get_default()
    
            if is_related_object:
                # If we are passed a related instance, set it using the
                # field.name instead of field.attname (e.g. "user" instead of
                # "user_id") so that the object gets properly cached (and type
                # checked) by the RelatedObjectDescriptor.
                if rel_obj is not _DEFERRED:
                    _setattr(self, field.name, rel_obj)
            else:
                if val is not _DEFERRED:
                    _setattr(self, field.attname, val)
    
        if kwargs:
            property_names = opts._property_names
            unexpected = ()
            for prop, value in kwargs.items():
                # Any remaining kwargs must correspond to properties or virtual
                # fields.
                if prop in property_names:
                    if value is not _DEFERRED:
                        _setattr(self, prop, value)
                else:
                    try:
                        opts.get_field(prop)
                    except FieldDoesNotExist:
                        unexpected += (prop,)
                    else:
                        if value is not _DEFERRED:
                            _setattr(self, prop, value)
            if unexpected:
                unexpected_names = ", ".join(repr(n) for n in unexpected)
>               raise TypeError(
                    f"{cls.__name__}() got unexpected keyword arguments: "
                    f"{unexpected_names}"
                )
E               TypeError: DocumentType() got unexpected keyword arguments: 'prefix'

/usr/local/lib/python3.11/site-packages/django/db/models/base.py:567: TypeError
_ ERROR at setup of TestApprovalRejections.test_approval_rejection_bypasses_review _

self = <apps.workflows.tests.test_workflow_rejections.TestApprovalRejections object at 0x7e0a0030af10>

    def setup_method(self):
        """Setup test data"""
        self.client = APIClient()
    
        # Create users
        self.author = User.objects.create_user(
            username='test_author',
            password='test123'
        )
    
        self.approver = User.objects.create_user(
            username='test_approver',
            password='test123'
        )
    
        # Assign approver role
        approver_role, _ = Role.objects.get_or_create(
            name='Document Approver',
            defaults={'module': 'S2', 'permission_level': 'approver'}
        )
        UserRole.objects.create(user=self.approver, role=approver_role, is_active=True)
    
        # Create document type
>       self.doc_type = DocumentType.objects.create(
            code='TST', name='Test Document', prefix='TST'
        )

apps/workflows/tests/test_workflow_rejections.py:183: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.11/site-packages/django/db/models/manager.py:87: in manager_method
    return getattr(self.get_queryset(), name)(*args, **kwargs)
/usr/local/lib/python3.11/site-packages/django/db/models/query.py:656: in create
    obj = self.model(**kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <DocumentType: Test Document (TST)>, args = ()
kwargs = {'prefix': 'TST'}, cls = <class 'apps.documents.models.DocumentType'>
opts = <Options for DocumentType>, _setattr = <built-in function setattr>
_DEFERRED = <Deferred field>
fields_iter = <tuple_iterator object at 0x7e09ffb10a00>, val = {}
field = <django.db.models.fields.json.JSONField: metadata>
is_related_object = False, property_names = frozenset({'pk'})

    def __init__(self, *args, **kwargs):
        # Alias some things as locals to avoid repeat global lookups
        cls = self.__class__
        opts = self._meta
        _setattr = setattr
        _DEFERRED = DEFERRED
        if opts.abstract:
            raise TypeError("Abstract models cannot be instantiated.")
    
        pre_init.send(sender=cls, args=args, kwargs=kwargs)
    
        # Set up the storage for instance state
        self._state = ModelState()
    
        # There is a rather weird disparity here; if kwargs, it's set, then args
        # overrides it. It should be one or the other; don't duplicate the work
        # The reason for the kwargs check is that standard iterator passes in by
        # args, and instantiation for iteration is 33% faster.
        if len(args) > len(opts.concrete_fields):
            # Daft, but matches old exception sans the err msg.
            raise IndexError("Number of args exceeds number of fields")
    
        if not kwargs:
            fields_iter = iter(opts.concrete_fields)
            # The ordering of the zip calls matter - zip throws StopIteration
            # when an iter throws it. So if the first iter throws it, the second
            # is *not* consumed. We rely on this, so don't change the order
            # without changing the logic.
            for val, field in zip(args, fields_iter):
                if val is _DEFERRED:
                    continue
                _setattr(self, field.attname, val)
        else:
            # Slower, kwargs-ready version.
            fields_iter = iter(opts.fields)
            for val, field in zip(args, fields_iter):
                if val is _DEFERRED:
                    continue
                _setattr(self, field.attname, val)
                if kwargs.pop(field.name, NOT_PROVIDED) is not NOT_PROVIDED:
                    raise TypeError(
                        f"{cls.__qualname__}() got both positional and "
                        f"keyword arguments for field '{field.name}'."
                    )
    
        # Now we're left with the unprocessed fields that *must* come from
        # keywords, or default.
    
        for field in fields_iter:
            is_related_object = False
            # Virtual field
            if field.attname not in kwargs and field.column is None:
                continue
            if kwargs:
                if isinstance(field.remote_field, ForeignObjectRel):
                    try:
                        # Assume object instance was passed in.
                        rel_obj = kwargs.pop(field.name)
                        is_related_object = True
                    except KeyError:
                        try:
                            # Object instance wasn't passed in -- must be an ID.
                            val = kwargs.pop(field.attname)
                        except KeyError:
                            val = field.get_default()
                else:
                    try:
                        val = kwargs.pop(field.attname)
                    except KeyError:
                        # This is done with an exception rather than the
                        # default argument on pop because we don't want
                        # get_default() to be evaluated, and then not used.
                        # Refs #12057.
                        val = field.get_default()
            else:
                val = field.get_default()
    
            if is_related_object:
                # If we are passed a related instance, set it using the
                # field.name instead of field.attname (e.g. "user" instead of
                # "user_id") so that the object gets properly cached (and type
                # checked) by the RelatedObjectDescriptor.
                if rel_obj is not _DEFERRED:
                    _setattr(self, field.name, rel_obj)
            else:
                if val is not _DEFERRED:
                    _setattr(self, field.attname, val)
    
        if kwargs:
            property_names = opts._property_names
            unexpected = ()
            for prop, value in kwargs.items():
                # Any remaining kwargs must correspond to properties or virtual
                # fields.
                if prop in property_names:
                    if value is not _DEFERRED:
                        _setattr(self, prop, value)
                else:
                    try:
                        opts.get_field(prop)
                    except FieldDoesNotExist:
                        unexpected += (prop,)
                    else:
                        if value is not _DEFERRED:
                            _setattr(self, prop, value)
            if unexpected:
                unexpected_names = ", ".join(repr(n) for n in unexpected)
>               raise TypeError(
                    f"{cls.__name__}() got unexpected keyword arguments: "
                    f"{unexpected_names}"
                )
E               TypeError: DocumentType() got unexpected keyword arguments: 'prefix'

/usr/local/lib/python3.11/site-packages/django/db/models/base.py:567: TypeError
_ ERROR at setup of TestRejectionWorkflowBehavior.test_document_can_be_resubmitted_after_rejection _

self = <apps.workflows.tests.test_workflow_rejections.TestRejectionWorkflowBehavior object at 0x7e0a0030be10>

    def setup_method(self):
        """Setup test data"""
        self.client = APIClient()
    
        # Create users
        self.author = User.objects.create_user(
            username='test_author',
            password='test123'
        )
    
        self.reviewer = User.objects.create_user(
            username='test_reviewer',
            password='test123'
        )
    
        # Assign roles
        reviewer_role, _ = Role.objects.get_or_create(
            name='Document Reviewer',
            defaults={'module': 'S2', 'permission_level': 'reviewer'}
        )
        UserRole.objects.create(user=self.reviewer, role=reviewer_role, is_active=True)
    
        # Create document type
>       self.doc_type = DocumentType.objects.create(
            code='TST', name='Test Document', prefix='TST'
        )

apps/workflows/tests/test_workflow_rejections.py:278: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.11/site-packages/django/db/models/manager.py:87: in manager_method
    return getattr(self.get_queryset(), name)(*args, **kwargs)
/usr/local/lib/python3.11/site-packages/django/db/models/query.py:656: in create
    obj = self.model(**kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <DocumentType: Test Document (TST)>, args = ()
kwargs = {'prefix': 'TST'}, cls = <class 'apps.documents.models.DocumentType'>
opts = <Options for DocumentType>, _setattr = <built-in function setattr>
_DEFERRED = <Deferred field>
fields_iter = <tuple_iterator object at 0x7e09ff8c9720>, val = {}
field = <django.db.models.fields.json.JSONField: metadata>
is_related_object = False, property_names = frozenset({'pk'})

    def __init__(self, *args, **kwargs):
        # Alias some things as locals to avoid repeat global lookups
        cls = self.__class__
        opts = self._meta
        _setattr = setattr
        _DEFERRED = DEFERRED
        if opts.abstract:
            raise TypeError("Abstract models cannot be instantiated.")
    
        pre_init.send(sender=cls, args=args, kwargs=kwargs)
    
        # Set up the storage for instance state
        self._state = ModelState()
    
        # There is a rather weird disparity here; if kwargs, it's set, then args
        # overrides it. It should be one or the other; don't duplicate the work
        # The reason for the kwargs check is that standard iterator passes in by
        # args, and instantiation for iteration is 33% faster.
        if len(args) > len(opts.concrete_fields):
            # Daft, but matches old exception sans the err msg.
            raise IndexError("Number of args exceeds number of fields")
    
        if not kwargs:
            fields_iter = iter(opts.concrete_fields)
            # The ordering of the zip calls matter - zip throws StopIteration
            # when an iter throws it. So if the first iter throws it, the second
            # is *not* consumed. We rely on this, so don't change the order
            # without changing the logic.
            for val, field in zip(args, fields_iter):
                if val is _DEFERRED:
                    continue
                _setattr(self, field.attname, val)
        else:
            # Slower, kwargs-ready version.
            fields_iter = iter(opts.fields)
            for val, field in zip(args, fields_iter):
                if val is _DEFERRED:
                    continue
                _setattr(self, field.attname, val)
                if kwargs.pop(field.name, NOT_PROVIDED) is not NOT_PROVIDED:
                    raise TypeError(
                        f"{cls.__qualname__}() got both positional and "
                        f"keyword arguments for field '{field.name}'."
                    )
    
        # Now we're left with the unprocessed fields that *must* come from
        # keywords, or default.
    
        for field in fields_iter:
            is_related_object = False
            # Virtual field
            if field.attname not in kwargs and field.column is None:
                continue
            if kwargs:
                if isinstance(field.remote_field, ForeignObjectRel):
                    try:
                        # Assume object instance was passed in.
                        rel_obj = kwargs.pop(field.name)
                        is_related_object = True
                    except KeyError:
                        try:
                            # Object instance wasn't passed in -- must be an ID.
                            val = kwargs.pop(field.attname)
                        except KeyError:
                            val = field.get_default()
                else:
                    try:
                        val = kwargs.pop(field.attname)
                    except KeyError:
                        # This is done with an exception rather than the
                        # default argument on pop because we don't want
                        # get_default() to be evaluated, and then not used.
                        # Refs #12057.
                        val = field.get_default()
            else:
                val = field.get_default()
    
            if is_related_object:
                # If we are passed a related instance, set it using the
                # field.name instead of field.attname (e.g. "user" instead of
                # "user_id") so that the object gets properly cached (and type
                # checked) by the RelatedObjectDescriptor.
                if rel_obj is not _DEFERRED:
                    _setattr(self, field.name, rel_obj)
            else:
                if val is not _DEFERRED:
                    _setattr(self, field.attname, val)
    
        if kwargs:
            property_names = opts._property_names
            unexpected = ()
            for prop, value in kwargs.items():
                # Any remaining kwargs must correspond to properties or virtual
                # fields.
                if prop in property_names:
                    if value is not _DEFERRED:
                        _setattr(self, prop, value)
                else:
                    try:
                        opts.get_field(prop)
                    except FieldDoesNotExist:
                        unexpected += (prop,)
                    else:
                        if value is not _DEFERRED:
                            _setattr(self, prop, value)
            if unexpected:
                unexpected_names = ", ".join(repr(n) for n in unexpected)
>               raise TypeError(
                    f"{cls.__name__}() got unexpected keyword arguments: "
                    f"{unexpected_names}"
                )
E               TypeError: DocumentType() got unexpected keyword arguments: 'prefix'

/usr/local/lib/python3.11/site-packages/django/db/models/base.py:567: TypeError
_ ERROR at setup of TestRejectionWorkflowBehavior.test_rejection_count_tracking _

self = <apps.workflows.tests.test_workflow_rejections.TestRejectionWorkflowBehavior object at 0x7e0a00308dd0>

    def setup_method(self):
        """Setup test data"""
        self.client = APIClient()
    
        # Create users
        self.author = User.objects.create_user(
            username='test_author',
            password='test123'
        )
    
        self.reviewer = User.objects.create_user(
            username='test_reviewer',
            password='test123'
        )
    
        # Assign roles
        reviewer_role, _ = Role.objects.get_or_create(
            name='Document Reviewer',
            defaults={'module': 'S2', 'permission_level': 'reviewer'}
        )
        UserRole.objects.create(user=self.reviewer, role=reviewer_role, is_active=True)
    
        # Create document type
>       self.doc_type = DocumentType.objects.create(
            code='TST', name='Test Document', prefix='TST'
        )

apps/workflows/tests/test_workflow_rejections.py:278: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.11/site-packages/django/db/models/manager.py:87: in manager_method
    return getattr(self.get_queryset(), name)(*args, **kwargs)
/usr/local/lib/python3.11/site-packages/django/db/models/query.py:656: in create
    obj = self.model(**kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <DocumentType: Test Document (TST)>, args = ()
kwargs = {'prefix': 'TST'}, cls = <class 'apps.documents.models.DocumentType'>
opts = <Options for DocumentType>, _setattr = <built-in function setattr>
_DEFERRED = <Deferred field>
fields_iter = <tuple_iterator object at 0x7e09ff8bdde0>, val = {}
field = <django.db.models.fields.json.JSONField: metadata>
is_related_object = False, property_names = frozenset({'pk'})

    def __init__(self, *args, **kwargs):
        # Alias some things as locals to avoid repeat global lookups
        cls = self.__class__
        opts = self._meta
        _setattr = setattr
        _DEFERRED = DEFERRED
        if opts.abstract:
            raise TypeError("Abstract models cannot be instantiated.")
    
        pre_init.send(sender=cls, args=args, kwargs=kwargs)
    
        # Set up the storage for instance state
        self._state = ModelState()
    
        # There is a rather weird disparity here; if kwargs, it's set, then args
        # overrides it. It should be one or the other; don't duplicate the work
        # The reason for the kwargs check is that standard iterator passes in by
        # args, and instantiation for iteration is 33% faster.
        if len(args) > len(opts.concrete_fields):
            # Daft, but matches old exception sans the err msg.
            raise IndexError("Number of args exceeds number of fields")
    
        if not kwargs:
            fields_iter = iter(opts.concrete_fields)
            # The ordering of the zip calls matter - zip throws StopIteration
            # when an iter throws it. So if the first iter throws it, the second
            # is *not* consumed. We rely on this, so don't change the order
            # without changing the logic.
            for val, field in zip(args, fields_iter):
                if val is _DEFERRED:
                    continue
                _setattr(self, field.attname, val)
        else:
            # Slower, kwargs-ready version.
            fields_iter = iter(opts.fields)
            for val, field in zip(args, fields_iter):
                if val is _DEFERRED:
                    continue
                _setattr(self, field.attname, val)
                if kwargs.pop(field.name, NOT_PROVIDED) is not NOT_PROVIDED:
                    raise TypeError(
                        f"{cls.__qualname__}() got both positional and "
                        f"keyword arguments for field '{field.name}'."
                    )
    
        # Now we're left with the unprocessed fields that *must* come from
        # keywords, or default.
    
        for field in fields_iter:
            is_related_object = False
            # Virtual field
            if field.attname not in kwargs and field.column is None:
                continue
            if kwargs:
                if isinstance(field.remote_field, ForeignObjectRel):
                    try:
                        # Assume object instance was passed in.
                        rel_obj = kwargs.pop(field.name)
                        is_related_object = True
                    except KeyError:
                        try:
                            # Object instance wasn't passed in -- must be an ID.
                            val = kwargs.pop(field.attname)
                        except KeyError:
                            val = field.get_default()
                else:
                    try:
                        val = kwargs.pop(field.attname)
                    except KeyError:
                        # This is done with an exception rather than the
                        # default argument on pop because we don't want
                        # get_default() to be evaluated, and then not used.
                        # Refs #12057.
                        val = field.get_default()
            else:
                val = field.get_default()
    
            if is_related_object:
                # If we are passed a related instance, set it using the
                # field.name instead of field.attname (e.g. "user" instead of
                # "user_id") so that the object gets properly cached (and type
                # checked) by the RelatedObjectDescriptor.
                if rel_obj is not _DEFERRED:
                    _setattr(self, field.name, rel_obj)
            else:
                if val is not _DEFERRED:
                    _setattr(self, field.attname, val)
    
        if kwargs:
            property_names = opts._property_names
            unexpected = ()
            for prop, value in kwargs.items():
                # Any remaining kwargs must correspond to properties or virtual
                # fields.
                if prop in property_names:
                    if value is not _DEFERRED:
                        _setattr(self, prop, value)
                else:
                    try:
                        opts.get_field(prop)
                    except FieldDoesNotExist:
                        unexpected += (prop,)
                    else:
                        if value is not _DEFERRED:
                            _setattr(self, prop, value)
            if unexpected:
                unexpected_names = ", ".join(repr(n) for n in unexpected)
>               raise TypeError(
                    f"{cls.__name__}() got unexpected keyword arguments: "
                    f"{unexpected_names}"
                )
E               TypeError: DocumentType() got unexpected keyword arguments: 'prefix'

/usr/local/lib/python3.11/site-packages/django/db/models/base.py:567: TypeError
_ ERROR at setup of TestRejectionWorkflowBehavior.test_multiple_rejection_cycles _

self = <apps.workflows.tests.test_workflow_rejections.TestRejectionWorkflowBehavior object at 0x7e0a004f75d0>

    def setup_method(self):
        """Setup test data"""
        self.client = APIClient()
    
        # Create users
        self.author = User.objects.create_user(
            username='test_author',
            password='test123'
        )
    
        self.reviewer = User.objects.create_user(
            username='test_reviewer',
            password='test123'
        )
    
        # Assign roles
        reviewer_role, _ = Role.objects.get_or_create(
            name='Document Reviewer',
            defaults={'module': 'S2', 'permission_level': 'reviewer'}
        )
        UserRole.objects.create(user=self.reviewer, role=reviewer_role, is_active=True)
    
        # Create document type
>       self.doc_type = DocumentType.objects.create(
            code='TST', name='Test Document', prefix='TST'
        )

apps/workflows/tests/test_workflow_rejections.py:278: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.11/site-packages/django/db/models/manager.py:87: in manager_method
    return getattr(self.get_queryset(), name)(*args, **kwargs)
/usr/local/lib/python3.11/site-packages/django/db/models/query.py:656: in create
    obj = self.model(**kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <DocumentType: Test Document (TST)>, args = ()
kwargs = {'prefix': 'TST'}, cls = <class 'apps.documents.models.DocumentType'>
opts = <Options for DocumentType>, _setattr = <built-in function setattr>
_DEFERRED = <Deferred field>
fields_iter = <tuple_iterator object at 0x7e09ffb77b50>, val = {}
field = <django.db.models.fields.json.JSONField: metadata>
is_related_object = False, property_names = frozenset({'pk'})

    def __init__(self, *args, **kwargs):
        # Alias some things as locals to avoid repeat global lookups
        cls = self.__class__
        opts = self._meta
        _setattr = setattr
        _DEFERRED = DEFERRED
        if opts.abstract:
            raise TypeError("Abstract models cannot be instantiated.")
    
        pre_init.send(sender=cls, args=args, kwargs=kwargs)
    
        # Set up the storage for instance state
        self._state = ModelState()
    
        # There is a rather weird disparity here; if kwargs, it's set, then args
        # overrides it. It should be one or the other; don't duplicate the work
        # The reason for the kwargs check is that standard iterator passes in by
        # args, and instantiation for iteration is 33% faster.
        if len(args) > len(opts.concrete_fields):
            # Daft, but matches old exception sans the err msg.
            raise IndexError("Number of args exceeds number of fields")
    
        if not kwargs:
            fields_iter = iter(opts.concrete_fields)
            # The ordering of the zip calls matter - zip throws StopIteration
            # when an iter throws it. So if the first iter throws it, the second
            # is *not* consumed. We rely on this, so don't change the order
            # without changing the logic.
            for val, field in zip(args, fields_iter):
                if val is _DEFERRED:
                    continue
                _setattr(self, field.attname, val)
        else:
            # Slower, kwargs-ready version.
            fields_iter = iter(opts.fields)
            for val, field in zip(args, fields_iter):
                if val is _DEFERRED:
                    continue
                _setattr(self, field.attname, val)
                if kwargs.pop(field.name, NOT_PROVIDED) is not NOT_PROVIDED:
                    raise TypeError(
                        f"{cls.__qualname__}() got both positional and "
                        f"keyword arguments for field '{field.name}'."
                    )
    
        # Now we're left with the unprocessed fields that *must* come from
        # keywords, or default.
    
        for field in fields_iter:
            is_related_object = False
            # Virtual field
            if field.attname not in kwargs and field.column is None:
                continue
            if kwargs:
                if isinstance(field.remote_field, ForeignObjectRel):
                    try:
                        # Assume object instance was passed in.
                        rel_obj = kwargs.pop(field.name)
                        is_related_object = True
                    except KeyError:
                        try:
                            # Object instance wasn't passed in -- must be an ID.
                            val = kwargs.pop(field.attname)
                        except KeyError:
                            val = field.get_default()
                else:
                    try:
                        val = kwargs.pop(field.attname)
                    except KeyError:
                        # This is done with an exception rather than the
                        # default argument on pop because we don't want
                        # get_default() to be evaluated, and then not used.
                        # Refs #12057.
                        val = field.get_default()
            else:
                val = field.get_default()
    
            if is_related_object:
                # If we are passed a related instance, set it using the
                # field.name instead of field.attname (e.g. "user" instead of
                # "user_id") so that the object gets properly cached (and type
                # checked) by the RelatedObjectDescriptor.
                if rel_obj is not _DEFERRED:
                    _setattr(self, field.name, rel_obj)
            else:
                if val is not _DEFERRED:
                    _setattr(self, field.attname, val)
    
        if kwargs:
            property_names = opts._property_names
            unexpected = ()
            for prop, value in kwargs.items():
                # Any remaining kwargs must correspond to properties or virtual
                # fields.
                if prop in property_names:
                    if value is not _DEFERRED:
                        _setattr(self, prop, value)
                else:
                    try:
                        opts.get_field(prop)
                    except FieldDoesNotExist:
                        unexpected += (prop,)
                    else:
                        if value is not _DEFERRED:
                            _setattr(self, prop, value)
            if unexpected:
                unexpected_names = ", ".join(repr(n) for n in unexpected)
>               raise TypeError(
                    f"{cls.__name__}() got unexpected keyword arguments: "
                    f"{unexpected_names}"
                )
E               TypeError: DocumentType() got unexpected keyword arguments: 'prefix'

/usr/local/lib/python3.11/site-packages/django/db/models/base.py:567: TypeError
_ ERROR at setup of TestWorkflowAuditTrail.test_audit_trail_created_on_status_change _

self = <apps.audit.tests.test_workflow_audit_trail.TestWorkflowAuditTrail object at 0x7e0a003537d0>

    def setup_method(self):
        """Setup test data"""
        self.author = User.objects.create_user(
            username='audit_author',
            password='test123'
        )
        self.reviewer = User.objects.create_user(
            username='audit_reviewer',
            password='test123'
        )
    
        # Create WorkflowType objects (REQUIRED for lifecycle service)
        self.review_workflow_type = WorkflowType.objects.create(
            name='Document Review',
            workflow_type='REVIEW',
            created_by=self.author
        )
        self.approval_workflow_type = WorkflowType.objects.create(
            name='Document Approval',
            workflow_type='APPROVAL',
            created_by=self.author
        )
    
        # Create DocumentState objects (REQUIRED for workflow transitions)
        for code, name in [
            ('DRAFT', 'Draft'),
            ('UNDER_REVIEW', 'Under Review'),
            ('REVIEW_COMPLETED', 'Review Completed'),
            ('PENDING_APPROVAL', 'Pending Approval'),
            ('APPROVED_PENDING_EFFECTIVE', 'Approved Pending Effective'),
            ('EFFECTIVE', 'Effective'),
        ]:
>           DocumentState.objects.create(
                name=name,
                code=code
            )
E           NameError: name 'DocumentState' is not defined

apps/audit/tests/test_workflow_audit_trail.py:62: NameError
_ ERROR at setup of TestWorkflowAuditTrail.test_audit_trail_captures_user_info _

self = <apps.audit.tests.test_workflow_audit_trail.TestWorkflowAuditTrail object at 0x7e0a00353c50>

    def setup_method(self):
        """Setup test data"""
        self.author = User.objects.create_user(
            username='audit_author',
            password='test123'
        )
        self.reviewer = User.objects.create_user(
            username='audit_reviewer',
            password='test123'
        )
    
        # Create WorkflowType objects (REQUIRED for lifecycle service)
        self.review_workflow_type = WorkflowType.objects.create(
            name='Document Review',
            workflow_type='REVIEW',
            created_by=self.author
        )
        self.approval_workflow_type = WorkflowType.objects.create(
            name='Document Approval',
            workflow_type='APPROVAL',
            created_by=self.author
        )
    
        # Create DocumentState objects (REQUIRED for workflow transitions)
        for code, name in [
            ('DRAFT', 'Draft'),
            ('UNDER_REVIEW', 'Under Review'),
            ('REVIEW_COMPLETED', 'Review Completed'),
            ('PENDING_APPROVAL', 'Pending Approval'),
            ('APPROVED_PENDING_EFFECTIVE', 'Approved Pending Effective'),
            ('EFFECTIVE', 'Effective'),
        ]:
>           DocumentState.objects.create(
                name=name,
                code=code
            )
E           NameError: name 'DocumentState' is not defined

apps/audit/tests/test_workflow_audit_trail.py:62: NameError
_ ERROR at setup of TestWorkflowAuditTrail.test_audit_trail_captures_timestamp _

self = <apps.audit.tests.test_workflow_audit_trail.TestWorkflowAuditTrail object at 0x7e0a00353e10>

    def setup_method(self):
        """Setup test data"""
        self.author = User.objects.create_user(
            username='audit_author',
            password='test123'
        )
        self.reviewer = User.objects.create_user(
            username='audit_reviewer',
            password='test123'
        )
    
        # Create WorkflowType objects (REQUIRED for lifecycle service)
        self.review_workflow_type = WorkflowType.objects.create(
            name='Document Review',
            workflow_type='REVIEW',
            created_by=self.author
        )
        self.approval_workflow_type = WorkflowType.objects.create(
            name='Document Approval',
            workflow_type='APPROVAL',
            created_by=self.author
        )
    
        # Create DocumentState objects (REQUIRED for workflow transitions)
        for code, name in [
            ('DRAFT', 'Draft'),
            ('UNDER_REVIEW', 'Under Review'),
            ('REVIEW_COMPLETED', 'Review Completed'),
            ('PENDING_APPROVAL', 'Pending Approval'),
            ('APPROVED_PENDING_EFFECTIVE', 'Approved Pending Effective'),
            ('EFFECTIVE', 'Effective'),
        ]:
>           DocumentState.objects.create(
                name=name,
                code=code
            )
E           NameError: name 'DocumentState' is not defined

apps/audit/tests/test_workflow_audit_trail.py:62: NameError
_ ERROR at setup of TestWorkflowAuditTrail.test_audit_trail_captures_status_change _

self = <apps.audit.tests.test_workflow_audit_trail.TestWorkflowAuditTrail object at 0x7e0a003520d0>

    def setup_method(self):
        """Setup test data"""
        self.author = User.objects.create_user(
            username='audit_author',
            password='test123'
        )
        self.reviewer = User.objects.create_user(
            username='audit_reviewer',
            password='test123'
        )
    
        # Create WorkflowType objects (REQUIRED for lifecycle service)
        self.review_workflow_type = WorkflowType.objects.create(
            name='Document Review',
            workflow_type='REVIEW',
            created_by=self.author
        )
        self.approval_workflow_type = WorkflowType.objects.create(
            name='Document Approval',
            workflow_type='APPROVAL',
            created_by=self.author
        )
    
        # Create DocumentState objects (REQUIRED for workflow transitions)
        for code, name in [
            ('DRAFT', 'Draft'),
            ('UNDER_REVIEW', 'Under Review'),
            ('REVIEW_COMPLETED', 'Review Completed'),
            ('PENDING_APPROVAL', 'Pending Approval'),
            ('APPROVED_PENDING_EFFECTIVE', 'Approved Pending Effective'),
            ('EFFECTIVE', 'Effective'),
        ]:
>           DocumentState.objects.create(
                name=name,
                code=code
            )
E           NameError: name 'DocumentState' is not defined

apps/audit/tests/test_workflow_audit_trail.py:62: NameError
__ ERROR at setup of TestWorkflowAuditTrail.test_audit_trail_captures_comment __

self = <apps.audit.tests.test_workflow_audit_trail.TestWorkflowAuditTrail object at 0x7e0a00350350>

    def setup_method(self):
        """Setup test data"""
        self.author = User.objects.create_user(
            username='audit_author',
            password='test123'
        )
        self.reviewer = User.objects.create_user(
            username='audit_reviewer',
            password='test123'
        )
    
        # Create WorkflowType objects (REQUIRED for lifecycle service)
        self.review_workflow_type = WorkflowType.objects.create(
            name='Document Review',
            workflow_type='REVIEW',
            created_by=self.author
        )
        self.approval_workflow_type = WorkflowType.objects.create(
            name='Document Approval',
            workflow_type='APPROVAL',
            created_by=self.author
        )
    
        # Create DocumentState objects (REQUIRED for workflow transitions)
        for code, name in [
            ('DRAFT', 'Draft'),
            ('UNDER_REVIEW', 'Under Review'),
            ('REVIEW_COMPLETED', 'Review Completed'),
            ('PENDING_APPROVAL', 'Pending Approval'),
            ('APPROVED_PENDING_EFFECTIVE', 'Approved Pending Effective'),
            ('EFFECTIVE', 'Effective'),
        ]:
>           DocumentState.objects.create(
                name=name,
                code=code
            )
E           NameError: name 'DocumentState' is not defined

apps/audit/tests/test_workflow_audit_trail.py:62: NameError
____ ERROR at setup of TestWorkflowAuditTrail.test_audit_trail_is_immutable ____

self = <apps.audit.tests.test_workflow_audit_trail.TestWorkflowAuditTrail object at 0x7e0a00350bd0>

    def setup_method(self):
        """Setup test data"""
        self.author = User.objects.create_user(
            username='audit_author',
            password='test123'
        )
        self.reviewer = User.objects.create_user(
            username='audit_reviewer',
            password='test123'
        )
    
        # Create WorkflowType objects (REQUIRED for lifecycle service)
        self.review_workflow_type = WorkflowType.objects.create(
            name='Document Review',
            workflow_type='REVIEW',
            created_by=self.author
        )
        self.approval_workflow_type = WorkflowType.objects.create(
            name='Document Approval',
            workflow_type='APPROVAL',
            created_by=self.author
        )
    
        # Create DocumentState objects (REQUIRED for workflow transitions)
        for code, name in [
            ('DRAFT', 'Draft'),
            ('UNDER_REVIEW', 'Under Review'),
            ('REVIEW_COMPLETED', 'Review Completed'),
            ('PENDING_APPROVAL', 'Pending Approval'),
            ('APPROVED_PENDING_EFFECTIVE', 'Approved Pending Effective'),
            ('EFFECTIVE', 'Effective'),
        ]:
>           DocumentState.objects.create(
                name=name,
                code=code
            )
E           NameError: name 'DocumentState' is not defined

apps/audit/tests/test_workflow_audit_trail.py:62: NameError
_ ERROR at setup of TestWorkflowAuditTrail.test_audit_trail_filtering_by_user __

self = <apps.audit.tests.test_workflow_audit_trail.TestWorkflowAuditTrail object at 0x7e0a00350310>

    def setup_method(self):
        """Setup test data"""
        self.author = User.objects.create_user(
            username='audit_author',
            password='test123'
        )
        self.reviewer = User.objects.create_user(
            username='audit_reviewer',
            password='test123'
        )
    
        # Create WorkflowType objects (REQUIRED for lifecycle service)
        self.review_workflow_type = WorkflowType.objects.create(
            name='Document Review',
            workflow_type='REVIEW',
            created_by=self.author
        )
        self.approval_workflow_type = WorkflowType.objects.create(
            name='Document Approval',
            workflow_type='APPROVAL',
            created_by=self.author
        )
    
        # Create DocumentState objects (REQUIRED for workflow transitions)
        for code, name in [
            ('DRAFT', 'Draft'),
            ('UNDER_REVIEW', 'Under Review'),
            ('REVIEW_COMPLETED', 'Review Completed'),
            ('PENDING_APPROVAL', 'Pending Approval'),
            ('APPROVED_PENDING_EFFECTIVE', 'Approved Pending Effective'),
            ('EFFECTIVE', 'Effective'),
        ]:
>           DocumentState.objects.create(
                name=name,
                code=code
            )
E           NameError: name 'DocumentState' is not defined

apps/audit/tests/test_workflow_audit_trail.py:62: NameError
_ ERROR at setup of TestWorkflowAuditTrail.test_complete_workflow_audit_trail __

self = <apps.audit.tests.test_workflow_audit_trail.TestWorkflowAuditTrail object at 0x7e0a003517d0>

    def setup_method(self):
        """Setup test data"""
        self.author = User.objects.create_user(
            username='audit_author',
            password='test123'
        )
        self.reviewer = User.objects.create_user(
            username='audit_reviewer',
            password='test123'
        )
    
        # Create WorkflowType objects (REQUIRED for lifecycle service)
        self.review_workflow_type = WorkflowType.objects.create(
            name='Document Review',
            workflow_type='REVIEW',
            created_by=self.author
        )
        self.approval_workflow_type = WorkflowType.objects.create(
            name='Document Approval',
            workflow_type='APPROVAL',
            created_by=self.author
        )
    
        # Create DocumentState objects (REQUIRED for workflow transitions)
        for code, name in [
            ('DRAFT', 'Draft'),
            ('UNDER_REVIEW', 'Under Review'),
            ('REVIEW_COMPLETED', 'Review Completed'),
            ('PENDING_APPROVAL', 'Pending Approval'),
            ('APPROVED_PENDING_EFFECTIVE', 'Approved Pending Effective'),
            ('EFFECTIVE', 'Effective'),
        ]:
>           DocumentState.objects.create(
                name=name,
                code=code
            )
E           NameError: name 'DocumentState' is not defined

apps/audit/tests/test_workflow_audit_trail.py:62: NameError
=================================== FAILURES ===================================
___ TestDocumentVersioning.test_create_major_version_from_effective_document ___

self = <apps.workflows.tests.test_versioning_workflow.TestDocumentVersioning object at 0x7e0a00384410>

    def test_create_major_version_from_effective_document(self):
        """
        Test creating a major version (v1.0  v2.0) from an EFFECTIVE document.
    
        Expected behavior:
        - New document created with v2.0
        - New document starts in DRAFT status
        - Original document remains EFFECTIVE
        - New document copies metadata from original
        """
        result = self.lifecycle_service.start_version_workflow(
            existing_document=self.original_doc,
            user=self.author,
            new_version_data={
                'version_type': 'major',
                'reason_for_change': 'Major update with significant changes',
                'title': 'Updated Document v2.0'
            }
        )
    
>       assert result['success'] is True
E       KeyError: 'success'

apps/workflows/tests/test_versioning_workflow.py:133: KeyError
----------------------------- Captured stdout call -----------------------------
 Workflow created: SOP-2026-0001-v01.01 - REVIEW
___ TestDocumentVersioning.test_create_minor_version_from_effective_document ___

self = <apps.workflows.tests.test_versioning_workflow.TestDocumentVersioning object at 0x7e0a00384810>

    def test_create_minor_version_from_effective_document(self):
        """
        Test creating a minor version (v1.0  v1.1) from an EFFECTIVE document.
    
        Minor versions are for small corrections, typo fixes, etc.
        """
        result = self.lifecycle_service.start_version_workflow(
            existing_document=self.original_doc,
            user=self.author,
            new_version_data={
                'version_type': 'minor',
                'reason_for_change': 'Fixed typos and minor corrections',
                'title': 'Original Document v1.1'
            }
        )
    
>       assert result['success'] is True
E       KeyError: 'success'

apps/workflows/tests/test_versioning_workflow.py:166: KeyError
----------------------------- Captured stdout call -----------------------------
 Workflow created: SOP-2026-0001-v01.01 - REVIEW
______ TestDocumentVersioning.test_cannot_version_non_effective_document _______

self = <apps.workflows.tests.test_versioning_workflow.TestDocumentVersioning object at 0x7e0a00384b90>

    def test_cannot_version_non_effective_document(self):
        """
        Test that only EFFECTIVE documents can be versioned.
    
        DRAFT, UNDER_REVIEW, etc. documents should not allow versioning.
        """
        draft_doc = Document.objects.create(
            title='Draft Document',
            description='Still in draft',
            document_type=self.doc_type,
            document_source=self.doc_source,
            author=self.author,
            status='DRAFT',
            version_major=1,
            version_minor=0
        )
    
>       result = self.lifecycle_service.start_version_workflow(
            existing_document=draft_doc,
            user=self.author,
            new_version_data={
                'version_type': 'major',
                'reason_for_change': 'Should fail'
            }
        )

apps/workflows/tests/test_versioning_workflow.py:191: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <apps.workflows.document_lifecycle.DocumentLifecycleService object at 0x7e0a00070790>
existing_document = <Document: SOP-2026-0002-v01.00 - Draft Document (v01.00)>
user = <User: Version Author>
new_version_data = {'reason_for_change': 'Should fail', 'version_type': 'major'}

    def start_version_workflow(self, existing_document: Document, user: User,
                              new_version_data: Dict[str, Any]) -> Dict[str, Any]:
        """
        Start up-versioning workflow to create new version and supersede old.
    
        Process:
        1. Create new document version
        2. Start review workflow for new version
        3. When new version becomes effective, mark old as SUPERSEDED
    
        Args:
            existing_document: Current effective document
            user: User initiating versioning
            new_version_data: Data for new version (title, description, etc.)
    
        Returns:
            dict: Contains new_document and workflow info
        """
        with transaction.atomic():
            # Validate existing document
            if existing_document.status != 'EFFECTIVE':
>               raise ValidationError("Can only version EFFECTIVE documents")
E               django.core.exceptions.ValidationError: ['Can only version EFFECTIVE documents']

apps/workflows/document_lifecycle.py:586: ValidationError
_____ TestDocumentVersioning.test_versioned_document_follows_full_workflow _____

self = <apps.workflows.tests.test_versioning_workflow.TestDocumentVersioning object at 0x7e0a00385650>

    def test_versioned_document_follows_full_workflow(self):
        """
        Test that versioned documents must go through complete review/approval workflow.
    
        Even though it's based on an approved document, the new version
        must be reviewed and approved independently.
        """
        # Create v2.0
        result = self.lifecycle_service.start_version_workflow(
            existing_document=self.original_doc,
            user=self.author,
            new_version_data={
                'version_type': 'major',
                'reason_for_change': 'Major changes'
            }
        )
    
        new_doc = result['new_document']
    
        # Submit for review
        success = self.lifecycle_service.submit_for_review(
            document=new_doc,
            user=self.author,
            comment='Version 2.0 ready for review'
        )
>       assert success is True
E       assert False is True

apps/workflows/tests/test_versioning_workflow.py:228: AssertionError
----------------------------- Captured stdout call -----------------------------
 Workflow created: SOP-2026-0001-v01.01 - REVIEW
 submit_for_review called for SOP-2026-0001-v01.01
   Document status: DRAFT
   User: author_version
   Reviewer assigned: reviewer_version
 Found existing workflow: ID 3, state: DRAFT
 Transitioning workflow from DRAFT to PENDING_REVIEW...
Workflow transition failed: 'PENDING_REVIEW'
 Transition result: False
 Transition failed
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "/app/apps/workflows/document_lifecycle.py", line 1254, in _transition_workflow
    to_state = self.states[to_state_code]
               ~~~~~~~~~~~^^^^^^^^^^^^^^^
KeyError: 'PENDING_REVIEW'
_____________ TestDocumentVersioning.test_version_numbering_format _____________

self = <apps.workflows.tests.test_versioning_workflow.TestDocumentVersioning object at 0x7e0a00385390>

    def test_version_numbering_format(self):
        """
        Test that version numbers are formatted correctly as 01.00, 02.00, etc.
    
        This is important for consistent display and sorting.
        """
        result = self.lifecycle_service.start_version_workflow(
            existing_document=self.original_doc,
            user=self.author,
            new_version_data={
                'version_type': 'major',
                'reason_for_change': 'Test versioning'
            }
        )
    
        new_doc = result['new_document']
    
        # Test version_string property
>       assert new_doc.version_string == '02.00'
E       AssertionError: assert '01.01' == '02.00'
E         - 02.00
E         + 01.01

apps/workflows/tests/test_versioning_workflow.py:322: AssertionError
----------------------------- Captured stdout call -----------------------------
 Workflow created: SOP-2026-0001-v01.01 - REVIEW
_____________ TestDocumentVersioning.test_multiple_versions_chain ______________

self = <apps.workflows.tests.test_versioning_workflow.TestDocumentVersioning object at 0x7e0a003867d0>

    def test_multiple_versions_chain(self):
        """
        Test creating multiple versions: v1.0  v2.0  v3.0
    
        Ensures version chain works correctly.
        """
        # Create v2.0
        result2 = self.lifecycle_service.start_version_workflow(
            existing_document=self.original_doc,
            user=self.author,
            new_version_data={
                'version_type': 'major',
                'reason_for_change': 'Version 2'
            }
        )
        v2_doc = result2['new_document']
    
        # Make v2.0 effective
        v2_doc.status = 'EFFECTIVE'
        v2_doc.effective_date = date.today()
        v2_doc.reviewer = self.reviewer
        v2_doc.approver = self.approver
        v2_doc.save()
    
        # Create v3.0 from v2.0
        result3 = self.lifecycle_service.start_version_workflow(
            existing_document=v2_doc,
            user=self.author,
            new_version_data={
                'version_type': 'major',
                'reason_for_change': 'Version 3'
            }
        )
        v3_doc = result3['new_document']
    
>       assert v3_doc.version_major == 3
E       assert 1 == 3
E        +  where 1 = <Document: SOP-2026-0001-v01.02 - Original Document v1.0 (v01.02)>.version_major

apps/workflows/tests/test_versioning_workflow.py:381: AssertionError
----------------------------- Captured stdout call -----------------------------
 Workflow created: SOP-2026-0001-v01.01 - REVIEW
 Workflow created: SOP-2026-0001-v01.02 - REVIEW
_______ TestDocumentVersioning.test_cannot_create_version_without_reason _______

self = <apps.workflows.tests.test_versioning_workflow.TestDocumentVersioning object at 0x7e0a003870d0>

    def test_cannot_create_version_without_reason(self):
        """
        Test that creating a version requires a reason for change.
    
        This is a compliance requirement - all changes must be justified.
        """
        result = self.lifecycle_service.start_version_workflow(
            existing_document=self.original_doc,
            user=self.author,
            new_version_data={
                'version_type': 'major',
                'reason_for_change': ''  # Empty reason
            }
        )
    
        # Service should validate and require a reason
>       assert result['success'] is False or result['new_document'].reason_for_change
E       KeyError: 'success'

apps/workflows/tests/test_versioning_workflow.py:448: KeyError
----------------------------- Captured stdout call -----------------------------
 Workflow created: SOP-2026-0001-v01.01 - REVIEW
___ TestWorkflowNotifications.test_notification_created_on_submit_for_review ___

self = <apps.workflows.tests.test_workflow_notifications.TestWorkflowNotifications object at 0x7e0a00387bd0>

    def test_notification_created_on_submit_for_review(self):
        """Test notification sent to reviewer when document submitted"""
        # Submit for review
        success = self.lifecycle_service.submit_for_review(
            document=self.doc,
            user=self.author,
            comment='Please review'
        )
    
>       assert success is True
E       assert False is True

apps/workflows/tests/test_workflow_notifications.py:81: AssertionError
----------------------------- Captured stdout call -----------------------------
 submit_for_review called for RPT-2026-0001-v01.00
   Document status: DRAFT
   User: notif_author
   Reviewer assigned: notif_reviewer
 No active workflow found, creating new workflow...
 Workflow created: RPT-2026-0001-v01.00 - REVIEW
    Workflow created: ID 12, state: DRAFT
 Transitioning workflow from DRAFT to PENDING_REVIEW...
Workflow transition failed: 'PENDING_REVIEW'
 Transition result: False
 Transition failed
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "/app/apps/workflows/document_lifecycle.py", line 1254, in _transition_workflow
    to_state = self.states[to_state_code]
               ~~~~~~~~~~~^^^^^^^^^^^^^^^
KeyError: 'PENDING_REVIEW'
_______ TestWorkflowNotifications.test_notification_created_on_rejection _______

self = <apps.workflows.tests.test_workflow_notifications.TestWorkflowNotifications object at 0x7e0a00387510>

    def test_notification_created_on_rejection(self):
        """Test notification sent to author when document rejected"""
        # Set document to UNDER_REVIEW
        self.doc.status = 'UNDER_REVIEW'
        self.doc.save()
    
        # Reviewer rejects
>       success = self.lifecycle_service.complete_review(
            document=self.doc,
            user=self.reviewer,
            approved=False,
            comment='Needs corrections'
        )

apps/workflows/tests/test_workflow_notifications.py:95: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <apps.workflows.document_lifecycle.DocumentLifecycleService object at 0x7e0a00070790>
document = <Document: RPT-2026-0001-v01.00 - Test Document for Notifications (v01.00)>
user = <User: notif_reviewer>, approved = False, comment = 'Needs corrections'

    def complete_review(self, document: Document, user: User,
                       approved: bool = True, comment: str = '') -> bool:
        """
        Complete document review (UNDER_REVIEW  PENDING_APPROVAL or back to DRAFT).
    
        Args:
            document: Document being reviewed
            user: User completing review
            approved: True if review passed, False to reject back to DRAFT
            comment: Review comment (required)
    
        Returns:
            bool: True if successful
        """
        workflow = self._get_active_workflow(document)
        if not workflow:
>           raise ValidationError("No active workflow found for document")
E           django.core.exceptions.ValidationError: ['No active workflow found for document']

apps/workflows/document_lifecycle.py:236: ValidationError
_______ TestWorkflowNotifications.test_notification_created_on_approval ________

self = <apps.workflows.tests.test_workflow_notifications.TestWorkflowNotifications object at 0x7e0a00385a90>

    def test_notification_created_on_approval(self):
        """Test notification sent when document approved"""
        # Set document to PENDING_APPROVAL
        self.doc.status = 'PENDING_APPROVAL'
        self.doc.save()
    
        # Approve
        from datetime import date
>       success = self.lifecycle_service.approve_document(
            document=self.doc,
            user=self.approver,
            effective_date=date.today(),
            comment='Approved'
        )

apps/workflows/tests/test_workflow_notifications.py:114: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <apps.workflows.document_lifecycle.DocumentLifecycleService object at 0x7e0a00070790>
document = <Document: RPT-2026-0001-v01.00 - Test Document for Notifications (v01.00)>
user = <User: notif_approver>, effective_date = datetime.date(2026, 1, 10)
comment = 'Approved', approved = True

    def approve_document(self, document: Document, user: User,
                        effective_date: date, comment: str = '', approved: bool = True) -> bool:
        """
        Approve document with required effective date (PENDING_APPROVAL  APPROVED_PENDING_EFFECTIVE or APPROVED_AND_EFFECTIVE).
    
        Args:
            document: Document to approve
            user: User approving (must be assigned approver)
            effective_date: Date when document becomes effective (REQUIRED)
            comment: Approval comment
    
        Returns:
            bool: True if successful
        """
        workflow = self._get_active_workflow(document)
        if not workflow:
>           raise ValidationError("No active workflow found for document")
E           django.core.exceptions.ValidationError: ['No active workflow found for document']

apps/workflows/document_lifecycle.py:366: ValidationError
=============================== warnings summary ===============================
../usr/local/lib/python3.11/site-packages/django/conf/__init__.py:289
  /usr/local/lib/python3.11/site-packages/django/conf/__init__.py:289: RemovedInDjango51Warning: The STATICFILES_STORAGE setting is deprecated. Use STORAGES instead.
    warnings.warn(STATICFILES_STORAGE_DEPRECATED_MSG, RemovedInDjango51Warning)

../usr/local/lib/python3.11/site-packages/rest_framework_simplejwt/__init__.py:1
  /usr/local/lib/python3.11/site-packages/rest_framework_simplejwt/__init__.py:1: DeprecationWarning: pkg_resources is deprecated as an API. See https://setuptools.pypa.io/en/latest/pkg_resources.html
    from pkg_resources import DistributionNotFound, get_distribution

-- Docs: https://docs.pytest.org/en/stable/how-to/capture-warnings.html
=========================== short test summary info ============================
FAILED apps/workflows/tests/test_versioning_workflow.py::TestDocumentVersioning::test_create_major_version_from_effective_document
FAILED apps/workflows/tests/test_versioning_workflow.py::TestDocumentVersioning::test_create_minor_version_from_effective_document
FAILED apps/workflows/tests/test_versioning_workflow.py::TestDocumentVersioning::test_cannot_version_non_effective_document
FAILED apps/workflows/tests/test_versioning_workflow.py::TestDocumentVersioning::test_versioned_document_follows_full_workflow
FAILED apps/workflows/tests/test_versioning_workflow.py::TestDocumentVersioning::test_version_numbering_format
FAILED apps/workflows/tests/test_versioning_workflow.py::TestDocumentVersioning::test_multiple_versions_chain
FAILED apps/workflows/tests/test_versioning_workflow.py::TestDocumentVersioning::test_cannot_create_version_without_reason
FAILED apps/workflows/tests/test_workflow_notifications.py::TestWorkflowNotifications::test_notification_created_on_submit_for_review
FAILED apps/workflows/tests/test_workflow_notifications.py::TestWorkflowNotifications::test_notification_created_on_rejection
FAILED apps/workflows/tests/test_workflow_notifications.py::TestWorkflowNotifications::test_notification_created_on_approval
ERROR apps/workflows/tests/test_approval_workflow.py::TestSubmitForApproval::test_can_submit_reviewed_document_for_approval
ERROR apps/workflows/tests/test_approval_workflow.py::TestSubmitForApproval::test_cannot_submit_draft_for_approval
ERROR apps/workflows/tests/test_approval_workflow.py::TestApproverActions::test_approver_can_approve_document_with_effective_date
ERROR apps/workflows/tests/test_approval_workflow.py::TestApproverActions::test_approver_can_approve_with_immediate_effective_date
ERROR apps/workflows/tests/test_approval_workflow.py::TestApproverActions::test_approver_can_reject_document
ERROR apps/workflows/tests/test_approval_workflow.py::TestApproverActions::test_non_approver_cannot_approve_document
ERROR apps/workflows/tests/test_approval_workflow.py::TestApproverActions::test_approval_requires_effective_date
ERROR apps/workflows/tests/test_approval_workflow.py::TestApproverActions::test_cannot_approve_draft_document
ERROR apps/workflows/tests/test_approval_workflow.py::TestApproverActions::test_effective_date_cannot_be_in_past
ERROR apps/workflows/tests/test_approval_workflow.py::TestAutomaticEffectiveActivation::test_document_becomes_effective_on_scheduled_date
ERROR apps/workflows/tests/test_approval_workflow.py::TestAutomaticEffectiveActivation::test_future_dated_documents_remain_pending
ERROR apps/workflows/tests/test_obsolescence_workflow.py::TestDocumentObsolescence::test_approver_can_mark_document_obsolete
ERROR apps/workflows/tests/test_obsolescence_workflow.py::TestDocumentObsolescence::test_obsolescence_requires_reason
ERROR apps/workflows/tests/test_obsolescence_workflow.py::TestDocumentObsolescence::test_scheduled_obsolescence_date
ERROR apps/workflows/tests/test_obsolescence_workflow.py::TestDocumentObsolescence::test_immediate_obsolescence
ERROR apps/workflows/tests/test_obsolescence_workflow.py::TestDocumentObsolescence::test_cannot_obsolete_non_effective_document
ERROR apps/workflows/tests/test_obsolescence_workflow.py::TestDocumentObsolescence::test_author_cannot_mark_obsolete
ERROR apps/workflows/tests/test_obsolescence_workflow.py::TestDocumentObsolescence::test_obsolete_documents_are_read_only
ERROR apps/workflows/tests/test_review_workflow.py::TestSubmitForReview::test_author_can_submit_document_for_review
ERROR apps/workflows/tests/test_review_workflow.py::TestSubmitForReview::test_non_author_cannot_submit_for_review
ERROR apps/workflows/tests/test_review_workflow.py::TestSubmitForReview::test_cannot_submit_already_reviewed_document
ERROR apps/workflows/tests/test_review_workflow.py::TestReviewerActions::test_reviewer_can_approve_document
ERROR apps/workflows/tests/test_review_workflow.py::TestReviewerActions::test_reviewer_can_reject_document
ERROR apps/workflows/tests/test_review_workflow.py::TestReviewerActions::test_non_reviewer_cannot_approve_document
ERROR apps/workflows/tests/test_review_workflow.py::TestReviewerActions::test_author_cannot_review_own_document
ERROR apps/workflows/tests/test_review_workflow.py::TestReviewerActions::test_review_requires_comment
ERROR apps/workflows/tests/test_review_workflow.py::TestReviewerActions::test_cannot_review_draft_document
ERROR apps/workflows/tests/test_termination_workflow.py::TestDocumentTermination::test_author_can_terminate_draft_document
ERROR apps/workflows/tests/test_termination_workflow.py::TestDocumentTermination::test_author_can_terminate_under_review_document
ERROR apps/workflows/tests/test_termination_workflow.py::TestDocumentTermination::test_author_can_terminate_pending_approval_document
ERROR apps/workflows/tests/test_termination_workflow.py::TestDocumentTermination::test_termination_requires_reason
ERROR apps/workflows/tests/test_termination_workflow.py::TestDocumentTermination::test_cannot_terminate_effective_document
ERROR apps/workflows/tests/test_termination_workflow.py::TestDocumentTermination::test_non_author_cannot_terminate
ERROR apps/workflows/tests/test_termination_workflow.py::TestDocumentTermination::test_terminated_documents_are_read_only
ERROR apps/workflows/tests/test_workflow_notifications.py::TestWorkflowNotifications::test_notification_created_on_submit_for_review
ERROR apps/workflows/tests/test_workflow_rejections.py::TestReviewRejections::test_reject_with_detailed_comment
ERROR apps/workflows/tests/test_workflow_rejections.py::TestReviewRejections::test_reject_without_comment_should_fail
ERROR apps/workflows/tests/test_workflow_rejections.py::TestReviewRejections::test_rejection_creates_audit_trail
ERROR apps/workflows/tests/test_workflow_rejections.py::TestReviewRejections::test_author_notified_of_rejection
ERROR apps/workflows/tests/test_workflow_rejections.py::TestApprovalRejections::test_approver_reject_with_reason
ERROR apps/workflows/tests/test_workflow_rejections.py::TestApprovalRejections::test_approval_rejection_bypasses_review
ERROR apps/workflows/tests/test_workflow_rejections.py::TestRejectionWorkflowBehavior::test_document_can_be_resubmitted_after_rejection
ERROR apps/workflows/tests/test_workflow_rejections.py::TestRejectionWorkflowBehavior::test_rejection_count_tracking
ERROR apps/workflows/tests/test_workflow_rejections.py::TestRejectionWorkflowBehavior::test_multiple_rejection_cycles
ERROR apps/audit/tests/test_workflow_audit_trail.py::TestWorkflowAuditTrail::test_audit_trail_created_on_status_change
ERROR apps/audit/tests/test_workflow_audit_trail.py::TestWorkflowAuditTrail::test_audit_trail_captures_user_info
ERROR apps/audit/tests/test_workflow_audit_trail.py::TestWorkflowAuditTrail::test_audit_trail_captures_timestamp
ERROR apps/audit/tests/test_workflow_audit_trail.py::TestWorkflowAuditTrail::test_audit_trail_captures_status_change
ERROR apps/audit/tests/test_workflow_audit_trail.py::TestWorkflowAuditTrail::test_audit_trail_captures_comment
ERROR apps/audit/tests/test_workflow_audit_trail.py::TestWorkflowAuditTrail::test_audit_trail_is_immutable
ERROR apps/audit/tests/test_workflow_audit_trail.py::TestWorkflowAuditTrail::test_audit_trail_filtering_by_user
ERROR apps/audit/tests/test_workflow_audit_trail.py::TestWorkflowAuditTrail::test_complete_workflow_audit_trail
======= 10 failed, 27 passed, 2 warnings, 52 errors in 69.17s (0:01:09) ========
